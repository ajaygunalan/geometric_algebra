# Chapter 2: All Source Code
# Combined for analysis

================================================================================
FILE: src/chap2/ex1/chap2ex1.cpp
================================================================================
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// Copyright 2007, Daniel Fontijne, University of Amsterdam -- fontijne@science.uva.nl

#ifdef WIN32
#include <windows.h>
#endif

#if defined (__APPLE__) || defined (OSX)
	#include <OpenGL/gl.h>
	#include <OpenGL/glext.h>
	#include <OpenGL/glu.h>
	#include <GLUT/glut.h>
#else
	#include <GL/gl.h>
	#include <GL/glut.h>
#endif

#include <stdio.h>
#include <stdlib.h>

#include <vector>
#include <string>

#include <libgasandbox/common.h>
#include <libgasandbox/e2ga.h>
#include <libgasandbox/e2ga_draw.h>
#include <libgasandbox/gl_util.h>
#include <libgasandbox/glut_util.h>
#include <libgasandbox/draw.h>

using namespace e2ga;
using namespace mv_draw;

const char *WINDOW_TITLE = "Geometric Algebra, Chapter 2, Example 1: Drawing Bivectors";

// GLUT state information
int g_viewportWidth = 800;
int g_viewportHeight = 600;
int g_GLUTmenu;

bool g_drawParallelogram = true;


// *!*HTML_TAG*!* display
void display() {
	doIntelWarning(); // warn for possible problems with pciking on Intel graphics chipsets

	glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glViewport(0, 0, g_viewportWidth, g_viewportHeight);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(0, g_viewportWidth, 0, g_viewportHeight, -100.0, 100.0);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glEnable(GL_DEPTH_TEST);
	glDisable(GL_CULL_FACE);
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();

	// we store the label positions & text here:
	std::vector<std::string> labelString;
	std::vector<e2ga::vector> labelPos;

	mv_draw::g_drawState.m_pointSize = 0.005f;

	// how many bivectors? what spacing between them?:
	const float entryWidth = 2.75f;
	const float entryHeight = 3.5f;
	const int nbBivectorX = 6;
	const int nbBivectorY = 4;

	// scale / translate to right transform:
	const float scale = 40.0f;
	glScalef(scale, scale, scale);
	glTranslatef(entryWidth, ((float)nbBivectorY - 0.5f) * entryHeight, 0.0f);

	int posX = 0;

	e2ga::vector v1, v2, v1_plus_v2;
	bivector B;

	double step = 2 * M_PI / (nbBivectorX * nbBivectorY);
	for (double a = 0; a < 2 * M_PI; a += step) {
		// vector 1 is fixed to e1
		v1 = e1;

		// compute vector 2:
		v2 = cos(a) * e1 + sin(a) * e2;

		// compute the bivector:
		B = v1 ^ v2;

		// draw vector 1 (red), vector 2 (green)
		glColor3f(1.0f, 0.0f, 0.0f);
		draw(v1);
		glColor3f(0.0f, 1.0f, 0.0f);
		draw(v2);

		// draw outer product v1^v2:
		glColor3f(0.0f, 0.0f, 1.0f);
		if (!g_drawParallelogram) {
			draw(B);
		}
		else {
			glDisable(GL_CULL_FACE);

			v1_plus_v2 = v1 + v2;
			// draw QUAD with vertices
			// origin  ->  v1  ->  (v1+v2)  ->  v2
			glBegin(GL_QUADS);
			glVertex2f(0.0f, 0.0f);
			glVertex2f(v1.e1(), v1.e2());
			glVertex2f(v1_plus_v2.e1(), v1_plus_v2.e2());
			glVertex2f(v2.e1(), v2.e2());
			glEnd();
		}


		// store label of bivector:
		{
			labelString.push_back(B.toString());
			GLfloat pos[2];
			viewportCoordinates(e3ga::_vector(0.35f * entryHeight * e3ga::e2).getC(e3ga::vector_e1_e2_e3), pos);
			labelPos.push_back(e2ga::vector(vector_e1_e2, pos));
		}

		// translate to next entry:
		glTranslatef(entryWidth, 0.0f, 0.0f);
		posX++;
		if (posX == nbBivectorX) {
			posX = 0;
			glTranslatef(-(float)nbBivectorX * entryWidth, -entryHeight, 0.0f);
		}

	}

	glPopMatrix();

	// draw the labels:
	glColor3f(0.2f, 0.2f, 0.2f);
	void *font = GLUT_BITMAP_HELVETICA_12;
	for (unsigned int i = 0; i < labelString.size(); i++) {
		float w = getBitmapStringWidth(font, labelString[i].c_str());
		renderBitmapString(labelPos[i].e1() - 0.45f * w, labelPos[i].e2(), font, labelString[i].c_str());
	}


	glutSwapBuffers();
}

void reshape(GLint width, GLint height) {
	g_viewportWidth = width;
	g_viewportHeight = height;

}


void menuCallback(int value) {
	g_drawParallelogram = value != 0;

	// redraw viewport
	glutPostRedisplay();
}


int main(int argc, char*argv[]) {
	// profiling for Gaigen 2:
	e2ga::g2Profiling::init();
	e3ga::g2Profiling::init();

	// GLUT Window Initialization:
	glutInit (&argc, argv);
	glutInitWindowSize(g_viewportWidth, g_viewportHeight);
	glutInitDisplayMode( GLUT_RGB | GLUT_ALPHA | GLUT_DOUBLE | GLUT_DEPTH);
	glutCreateWindow(WINDOW_TITLE);

	// Register callbacks:
	glutDisplayFunc(display);
	glutReshapeFunc(reshape);

	g_GLUTmenu = glutCreateMenu(menuCallback);
	glutAddMenuEntry("disc", 0);
	glutAddMenuEntry("parallelogram", 1);
	glutAttachMenu(GLUT_LEFT_BUTTON);
	glutAttachMenu(GLUT_MIDDLE_BUTTON);
	glutAttachMenu(GLUT_RIGHT_BUTTON);

	glutMainLoop();

	return 0;
}


================================================================================
FILE: src/chap2/ex2/chap2ex2.cpp
================================================================================
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// Copyright 2007, Daniel Fontijne, University of Amsterdam -- fontijne@science.uva.nl

#ifdef WIN32
#include <windows.h>
#endif

#if defined (__APPLE__) || defined (OSX)
	#include <OpenGL/gl.h>
	#include <OpenGL/glext.h>
	#include <OpenGL/glu.h>
	#include <GLUT/glut.h>
#else
	#include <GL/gl.h>
	#include <GL/glut.h>
#endif

#include <stdio.h>
#include <stdlib.h>

#include <vector>
#include <string>

#include <libgasandbox/common.h>
#include <libgasandbox/e2ga.h>
#include <libgasandbox/e3ga_util.h>
#include <libgasandbox/gl_util.h>
#include <libgasandbox/glut_util.h>

using namespace e2ga;

const char *WINDOW_TITLE = "Geometric Algebra, Chapter 2, Example 2: Hidden Surface Removal";

// GLUT state information
int g_viewportWidth = 800;
int g_viewportHeight = 600;
int g_GLUTmenu;
// mouse position on last call to MouseButton() / MouseMotion()
e3ga::vector g_prevMousePos;
// when true, MouseMotion() will rotate the model
bool g_rotateModel = false;
bool g_rotateModelOutOfPlane = false;

// model info:
bool g_initModelRequired = true;
const char *g_modelName = "sphere";

// vertex positions: 2d vectors
std::vector<e2ga::vector> g_vertices2D;
// indices into the g_vertices2D vector:
std::vector<std::vector<int> > g_polygons2D;

e3ga::rotor g_modelRotor(e3ga::_rotor(1.0f));
std::string g_prevStatisticsModelName = "";

// model names:
const char *g_modelNames[] = {
"teapot",
"cube",
"sphere",
"cone",
"torus",
"dodecahedron",
"octahedron",
"tetrahedron",
"icosahedron",
NULL
};



void getGLUTmodel2D(const std::string &modelName);



void display() {
	doIntelWarning(); // warn for possible problems with pciking on Intel graphics chipsets

	glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	// get model, if required:
	if (g_initModelRequired) {
		g_initModelRequired = false;
		getGLUTmodel2D(g_modelName);
	}

	glEnable(GL_DEPTH_TEST);

	// DONT cull faces (we will do this ourselves!)
	glDisable(GL_CULL_FACE);
	// fill all polygons (otherwise they get turned into LINES)
	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

	glColor3f(0.0f, 0.0f, 0.0f);

	bivector B;

	// render model
	for (unsigned int i = 0; i < g_polygons2D.size(); i++) {
		// get 2D vertices of the polygon:
		const e2ga::vector &v1 = g_vertices2D[g_polygons2D[i][0]];
		const e2ga::vector &v2 = g_vertices2D[g_polygons2D[i][1]];
		const e2ga::vector &v3 = g_vertices2D[g_polygons2D[i][2]];

		// Exercise:
		// Insert code to remove back-facing polygons here.
		// You can extract the e1^e2 coordinate of a bivector 'B' using:
		// float c = B.e1e2();
		// ...

		// draw polygon
		glBegin(GL_POLYGON);
		for (unsigned int j = 0; j < g_polygons2D[i].size(); j++)
			glVertex2f(
				g_vertices2D[g_polygons2D[i][j]].e1(),
				g_vertices2D[g_polygons2D[i][j]].e2());
		glEnd();
	}

	glutSwapBuffers();
}

void reshape(GLint width, GLint height) {
	g_viewportWidth = width;
	g_viewportHeight = height;

	glViewport(0, 0, g_viewportWidth, g_viewportHeight);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(0, g_viewportWidth, 0, g_viewportHeight, -100.0, 100.0);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	// refresh model on next redraw
	g_initModelRequired = true;

	// redraw viewport
	glutPostRedisplay();
}

e3ga::vector mousePosToVector(int x, int y) {
	x -= g_viewportWidth / 2;
	y -= g_viewportHeight / 2;
	return e3ga::_vector((float)x * e3ga::e1 - (float)y * e3ga::e2);
}


void MouseButton(int button, int state, int x, int y) {
	if (button == GLUT_LEFT_BUTTON) {
		e3ga::vector mousePos = mousePosToVector(x, y);
		g_prevMousePos = mousePosToVector(x, y);
		g_rotateModel = true;
		if ((_Float(norm_e(mousePos)) / _Float(norm_e(g_viewportWidth * e1 + g_viewportHeight * e2))) < 0.2)
			g_rotateModelOutOfPlane = true;
		else g_rotateModelOutOfPlane = false;
	}
	else g_rotateModel = false;
}

void MouseMotion(int x, int y) {
	if (g_rotateModel) {
		// get mouse position, motion
		e3ga::vector mousePos = mousePosToVector(x, y);
		e3ga::vector motion = _vector(mousePos - g_prevMousePos);

		// update rotor
		if (g_rotateModelOutOfPlane)
			g_modelRotor = _rotor(e3ga::exp(0.005f * (motion ^ e3ga::e3)) * g_modelRotor);
		else g_modelRotor = _rotor(e3ga::exp(0.00001f * (motion ^ mousePos)) * g_modelRotor);


		// remember mouse pos for next motion:
		g_prevMousePos = mousePos;

		// refresh model on next redraw
		g_initModelRequired = true;

		// redraw viewport
		glutPostRedisplay();
	}
}

void menuCallback(int value) {
	g_modelName = g_modelNames[value];
	g_initModelRequired = true;
	glutPostRedisplay();
}


int main(int argc, char*argv[]) {
	// profiling for Gaigen 2:
	e2ga::g2Profiling::init();
	e3ga::g2Profiling::init();

	// GLUT Window Initialization:
	glutInit (&argc, argv);
	glutInitWindowSize(g_viewportWidth, g_viewportHeight);
	glutInitDisplayMode( GLUT_RGB | GLUT_ALPHA | GLUT_DOUBLE | GLUT_DEPTH);
	glutCreateWindow(WINDOW_TITLE);

	// Register callbacks:
	glutDisplayFunc(display);
	glutReshapeFunc(reshape);
	glutMouseFunc(MouseButton);
	glutMotionFunc(MouseMotion);


	g_GLUTmenu = glutCreateMenu(menuCallback);
	for (int i = 0; g_modelNames[i]; i++)
		glutAddMenuEntry(g_modelNames[i], i);
	glutAttachMenu(GLUT_MIDDLE_BUTTON);
	glutAttachMenu(GLUT_RIGHT_BUTTON);


	glutMainLoop();

	return 0;
}

void getGLUTmodel2D(const std::string &modelName) {
	// DONT cull faces (we will do this ourselves!)
	glDisable(GL_CULL_FACE);
	// fill all polygons (otherwise they get turned into LINES
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

	// setup projection & transform for the model:
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	const float screenWidth = 1600.0f;
	glFrustum(
		-(float)g_viewportWidth / screenWidth, (float)g_viewportWidth / screenWidth,
		-(float)g_viewportHeight / screenWidth, (float)g_viewportHeight / screenWidth,
		1.0, 100.0);

	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();
	glTranslatef(0.0, 0.0, -10.0f);

	rotorGLMult(g_modelRotor);


	glColor3f(0.0f, 0.0f, 0.0f);

	// buffer for OpenGL feedback.
	// Format will be:
	// GL_POLYGON_TOKEN
	// n (= 3)
	// vertex 0 x, vertex 0 y
	// vertex 1 x, vertex 1 y
	// vertex 2 x, vertex 2 y
	// GL_POLYGON_TOKEN etc etc
	std::vector<GLfloat> buffer(300000); // more than enough for the GLUT primitives

	// switch into feedback mode:
	glFeedbackBuffer((GLsizei)buffer.size(), GL_2D, &(buffer[0]));
	glRenderMode(GL_FEEDBACK);

	// render model
	if (modelName == "teapot")
		glutSolidTeapot(1.0);
	else if (modelName == "cube")
		glutSolidCube(1.0);
	else if (modelName == "sphere")
		glutSolidSphere(1.0, 16, 8);
	else if (modelName == "cone")
		glutSolidCone(1.0, 2.0, 16, 8);
	else if (modelName == "torus")
		glutSolidTorus(0.5, 1.0, 8, 16);
	else if (modelName == "dodecahedron")
		glutSolidDodecahedron();
	else if (modelName == "octahedron")
		glutSolidOctahedron();
	else if (modelName == "tetrahedron")
		glutSolidTetrahedron();
	else if (modelName == "icosahedron")
		glutSolidIcosahedron();

	int nbFeedback = glRenderMode(GL_RENDER);

	// parse the buffer:
	g_polygons2D.clear();
	g_vertices2D.clear();

	int idx = 0;
	while (idx < nbFeedback) {
		// check for polygon:
		if (buffer[idx] != GL_POLYGON_TOKEN) {
			fprintf(stderr, "Error parsing the feedback buffer!");
			break;
		}
		idx++;

		// number of vertices (3)
		int n = (int)buffer[idx];
		idx++;
		std::vector<int> vtxIdx(n);

		// get vertices:
		// Maybe todo later: don't duplicate identical vertices  . . .
		for (int i = 0; i < n; i++) {
			vtxIdx[i] = (int)g_vertices2D.size();
			g_vertices2D.push_back(_vector(buffer[idx] * e1 + buffer[idx+1] * e2));
			idx += 2;
		}

		g_polygons2D.push_back(vtxIdx);
	}

	if (g_prevStatisticsModelName != modelName) {
		printf("Model: %s, #polygons: %d, #vertices: %d\n", modelName.c_str(), g_polygons2D.size(), g_vertices2D.size());
		g_prevStatisticsModelName = modelName;
	}

	// restore transform & projection:
	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
	glMatrixMode(GL_MODELVIEW);

}


================================================================================
FILE: src/chap2/ex3/fields.cpp
================================================================================
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// Copyright 2007, Daniel Fontijne, University of Amsterdam -- fontijne@science.uva.nl

#include <math.h>

#include <libgasandbox/timing.h>

/*
This file contains all the field evaluators 
that came with the original matlab code
and some extra simple ones
*/

#include "fields.h"

extern float g_dx;
extern float g_dy;
extern float g_dz;
extern float g_omega;
extern float g_gamma;
extern float g_Rcore;

double g_fieldsCurrentTime = 0;

  
vector &vortex(const vector& p, vector& v) {
  
  float r;

  r = sqrtf(g_dx*g_dx + g_dy*g_dy + g_dz*g_dz);
  vector axis(vector_e1_e2_e3, g_dx/r,g_dy/r,g_dz/r);

  v = g_omega*axis+g_gamma*(((p^axis)*inverse(axis))*(axis*I3i));
  return v;	
}

/* Vortex field with varying perp component that may put a point singularity
   in the field */
vector &vortexS(const vector &p, vector &v) {
  float r;

  r = sqrtf(g_dx*g_dx + g_dy*g_dy + g_dz*g_dz);
  vector axis(vector_e1_e2_e3, g_dx/r,g_dy/r,g_dz/r);

  v = g_omega*((p<<axis)*inverse(axis))+g_gamma*(((p^axis)*inverse(axis))*(axis*I3i));
  return v;	
}

/* simple z-axis aligned vortex field */
vector &vortexA(const vector &p, vector &v) {
  float r;

  r = sqrtf(p.e1()*p.e1() + p.e2()*p.e2());
  v.set(vector_e1_e2_e3,-p.e2()/r,p.e1()/r,g_Rcore);
  return v;	
}

/* vortex field from paper */
vector &vortexO(const vector &p, vector &v) {
	float r;
	float z;
	r = sqrtf(p.e1()*p.e1() + p.e2()*p.e2());
	z = (float)(g_omega*(1.-g_Rcore/r));
	v.set(vector_e1_e2_e3, 
	      -g_gamma*p.e2()/r - g_omega*p.e3()*p.e1()/(r*r),
	      g_gamma*p.e1()/r - g_omega*p.e3()*p.e2()/(r*r),
	      z);
	return v;
}

vector &point3(const vector &p, vector &v) {
	
	v.set(vector_e1_e2_e3, 
		-p.e1(),
		-p.e2(), 
		-p.e3());
	return v;
}

vector &line3(const vector &p, vector &v) {
	
	v.set(vector_e1_e2_e3, 
		2.0f * (p.e1()),
		2.0f * (p.e2()), 
		0);
	return v;
}

vector &testFunc3(const vector &p, vector &v) {
	float c[3] = {p.e1() + 0.05f, p.e2() + 0.05f, p.e3() + 0.05f};
	v.set(vector_e1_e2_e3, 
		0,
		0, 
		5.0f * (p.e1() * p.e1() + p.e2() * p.e2()));
	return v;
}


vector &testFunc4(const vector &p, vector &v) {
	
	v.set(vector_e1_e2_e3, 
	      3*p.e1()*p.e1()*p.e2()*p.e2()*p.e2()*p.e3()*p.e3(),
	      3*p.e1()*p.e1()*p.e1()*p.e2()*p.e2()*p.e3()*p.e3(),
	      2*p.e1()*p.e1()*p.e1()*p.e2()*p.e2()*p.e2()*p.e3());
	return v;
}


vector &testFunc5(const vector &p, vector &v) {
	
	v.set(vector_e1_e2_e3, 
	      3*p.e1()*p.e1(),
	      3*p.e2()*p.e2(),
	      2*p.e3());
	return v;
}


vector &testFunc6(const vector &p, vector &v) {
	
	v.set(vector_e1_e2_e3, 
	      3*p.e1()*p.e1()+2*p.e1(),
	      3*p.e2()*p.e2(),
	      0);
	return v;
}

vector &testFunc7(const vector &p, vector &v) {
	
	v.set(vector_e1_e2_e3, 
	      3*p.e1()*p.e1()*p.e2()*p.e2()*p.e2(),
	      3*p.e1()*p.e1()*p.e1()*p.e2()*p.e2(),
	      0);
	return v;
}

vector &testFunc8(const vector &p, vector &v) {
	
	bivector ii = _bivector(e1 ^ e2);
	rotor z =  _rotor(p.e1()+p.e2()*ii);
	rotor f = _rotor(z*z * inverse(z + 2) * inverse(z - 0.8f));
	v.set(vector_e1_e2_e3, _Float(f), f.e1e2(), 0.0f);
	return v;
}

vector &testFunc9(const vector &p, vector &v) {
	
	bivector ii = _bivector(e1 ^ e2);
	rotor z = _rotor(p.e1()+p.e2()*ii);
	rotor f = _rotor(inverse(z));
	v.set(vector_e1_e2_e3, _Float(f), f.e1e2(), 0.0f);
	return v;
}

vector &testFunc10(const vector &p, vector &v) {
	
	v.set(vector_e1_e2_e3, 
	      3*p.e1()*p.e1(),
	      3*p.e2()*p.e2(),
	      3*p.e3()*p.e3());
	return v;
}

vector &testFunc11(const vector &p, vector &v) {
	
	v.set(vector_e1_e2_e3, 
	      4*p.e1()*p.e1()*p.e1(),
	      4*p.e2()*p.e2()*p.e2(),
	      4*p.e3()*p.e3()*p.e3());
	return v;
}

vector &testFunc12(const vector &p, vector &v) {
	
	v.set(vector_e1_e2_e3, 
	      4*p.e1()*(p.e1()*p.e1()+p.e2()*p.e2()-p.e3()),
	      4*p.e2()*(p.e1()*p.e1()+p.e2()*p.e2()-p.e3()),
	      -2*(p.e1()*p.e1()+p.e2()*p.e2()-p.e3()));
	return v;
}

// ((p.e1()-0.5)*(p.e1()-0.5)+p.e2()*p.e2()-1)^2*(p.e1()*p.e1()+p.e2()*p.e2()+p.e3()*p.e3()-1)^2
vector &testFunc13(const vector &p, vector &v) {
	
	float A =(float)((p.e1()-0.5)*(p.e1()-0.5)+p.e2()*p.e2()-1.0f);
	float B = (float)(p.e1()*p.e1()+p.e2()*p.e2()+p.e3()*p.e3()-1.0f);
	v.set(vector_e1_e2_e3, 
	      4.0f*(p.e1()-0.5f)*A*B*B + 4*p.e1()*A*A*B,
	      4.0f*p.e2()*A*B*B + 4*p.e2()*A*A*B,
	      4.0f*p.e3()*A*A*B);
	return v;
}

// ((p.e1()-0.5)*(p.e1()-0.5)+p.e2()*p.e2()-1)^2 + (p.e1()*p.e1()+p.e2()*p.e2()+p.e3()*p.e3()-1)^2
vector &testFunc14(const vector &p, vector &v) {
	
	float A =((p.e1()-0.5f)*(p.e1()-0.5f)+p.e2()*p.e2()-1.0f);
	float B = (p.e1()*p.e1()+p.e2()*p.e2()+p.e3()*p.e3()-1.0f);
	v.set(vector_e1_e2_e3, 
	      4.0f*(p.e1()-0.5f)*A + 4.0f*p.e1()*B,
	      4.0f*p.e2()*A + 4.0f*p.e2()*B,
	      4.0f*p.e3()*B);
	return v;
}

// helix - 1 / [(x-cos(z))^2 + (y-sin(z))^2] = 1/A
vector &testFunc15(const vector &p, vector &v) {
	
	float cz = cos(p.e3()*2.0f); float sz = sin(p.e3()*2.0f);
	float A = (p.e1()-cz)*(p.e1()-cz) + (p.e2()-sz)*(p.e2()-sz);
	v.set(vector_e1_e2_e3, 
	      -2.0f*(p.e1()-cz)/(A*A),
	      -2.0f*(p.e2()-sz)/(A*A),
	      -2.0f*(-(p.e1()-cz)*sz+(p.e2()-sz)*cz)/(A*A));
	      
	return v;
}

vector &testFunc16(const vector &p, vector &v) {
	
	vector A = _vector(p.e1() * e1 + p.e2() * e2);
	vector B = _vector(sqrtf(p.e1()*p.e1()+p.e2()*p.e2())*e1);
	vector C = _vector(A * inverse(B) * A);
	v.set(vector_e1_e2_e3, 2.0f*C.e1(), 2.0f*C.e2(), 0.0f);
	return v;
}

vector &testFunc16a(const vector &p, vector &v) {
	vector A = _vector(p.e1()*e1 + p.e2()* e2);
	vector B = _vector(sqrtf(p.e1()*p.e1()+p.e2()*p.e2())*e1);
	vector C = _vector(A * inverse(B) * A);
	v.set(vector_e1_e2_e3, 2*C.e1(), 2*C.e2(), 2*p.e3());
	if ( 0 && fabs(C.e1())+fabs(C.e2())+fabs(C.e3()) < 1e-1 ) {
	  printf("*** p %g %g %g, cc %g %g %g\n",p.e1(),p.e2(),p.e3(), C.e1(), C.e2(), C.e3());
	  printf("    A = %g e1 + %g e2,   B = %g e1\n",
		 p.e1(), p.e2(), sqrtf(p.e1()*p.e1()+p.e2()*p.e2()));
	}
	return v;
}

// x^3/3 - xy^2 + z^2
vector &testFunc17(const vector &p, vector &v) {
	
	v.set(vector_e1_e2_e3, 
	      p.e1()*p.e1()-p.e2()*p.e2(),
	      -2*p.e1()*p.e2(),
	      2*p.e3());
	return v;
}

// x^3/3 - xy^2
vector &testFunc18(const vector &p, vector &v) {
	
	v.set(vector_e1_e2_e3, 
	      p.e1()*p.e1()-p.e2()*p.e2(),
	      -2*p.e1()*p.e2(),
	      0.0f);
	return v;
}

vector &helix3(const vector &p, vector &v) {
	
	v.set(vector_e1_e2_e3, 
		-p.e2(), p.e1(),
		(p.e1() * p.e1() + p.e2() * p.e2()) * p.e3());
	return v;
}

vector &const3(const vector &p, vector &v) {
	
	v.set(vector_e1_e2_e3, 1.0, 1.0, 1.0);
	return v;
}


/*
function [vx,vy,vz]=circ3(x,y,z)
	vx = 4*(x^2+y^2-1)*x*e1;
	vy = 4*(x^2+y^2-1)*y*e2;
	vz = 2*z*e3;
*/
vector &circ3(const vector &p, vector &v) {
	// fastest method:
	
	v.set(vector_e1_e2_e3,
		4 * (p.e1() * p.e1() + p.e2() * p.e2() - 1) * p.e1(), // e1 coordinate
		4 * (p.e1() * p.e1() + p.e2() * p.e2() - 1) * p.e2(), // e2 coordinate
		2 * p.e3()); // e3 coordinates

	/* less efficient alternative:
	v = 4 * (p.e1() * p.e1() + p.e2() * p.e2() - 1) * p.e1() * e3ga::e1 + 
		4 * (p.e1() * p.e1() + p.e2() * p.e2() - 1) * p.e2() * e3ga::e2 + 
		2 * p.e3() * e3ga::e3;
	*/

	/* (even less efficient) alternative:
	float e1c = p << e3ga::e1;
	float e2c = p << e3ga::e2;
	float e3c = p << e3ga::e3;
	v = 4 * (e1c * e1c + e2c * e2c - 1) * e1c * e3ga::e1 + 
		4 * (e1c * e1c + e2c * e2c - 1) * e2c * e3ga::e2 + 
		2 * e3c * e3ga::e3;
	*/
	return v;
}


/*
function [vx,vy,vz]=sphere3(x,y,z)
	vx = 4*(x^2+y^2+z^2-1)*x*e1;
	vy = 4*(x^2+y^2+z^2-1)*y*e2;
	vz = 4*(x^2+y^2+z^2-1)*z*e3;
*/
vector &sphere3(const vector &p, vector &v) {
	// fastest method:
	
	v.set(vector_e1_e2_e3,
		4 * (p.e1() * p.e1() + p.e2() * p.e2() + p.e3() * p.e3() - 1) * p.e1(), // e1 coordinate
		4 * (p.e1() * p.e1() + p.e2() * p.e2() + p.e3() * p.e3() - 1) * p.e2(), // e2 coordinate
		4 * (p.e1() * p.e1() + p.e2() * p.e2() + p.e3() * p.e3() - 1) * p.e3()); // e3 coordinate
	return v;
}

/*
function [vx,vy,vz]=eight2(x,y,z)
vx = (2*((x-1)^2+y^2-1)*x*(((x+1)^2+y^2-1)^2+z^2) + 2*((x+1)^2+y^2-1)*x*(((x-1)^2+y^2-1)^2+z^2))*e1;
vy = (2*((x-1)^2+y^2-1)*y*(((x+1)^2+y^2-1)^2+z^2) + 2*((x+1)^2+y^2-1)*y*(((x-1)^2+y^2-1)^2+z^2))*e2;
vz = (2*z*(((x+1)^2+y^2-1)^2+z^2)+2*z*(((x-1)^2+y^2-1)^2+z^2))*e3;
*/
vector &eight2(const vector &p, vector &v) {
	// fastest method:
	
	float tmp1, tmp2;

	tmp1 = (p.e1()+1) * (p.e1()+1)+p.e2() * p.e2()-1;
	tmp2 = (p.e1()-1) * (p.e1()-1)+p.e2() * p.e2()-1;
	tmp1 *= 2.0f;
	tmp2 *= 2.0f;


	v.set(vector_e1_e2_e3,
		(2*((p.e1()-1) * (p.e1()-1)+p.e2() * p.e2()-1)*p.e1()*(tmp1 +p.e3() * p.e3()) + 
		2*((p.e1()+1) * (p.e1()+1)+p.e2() * p.e2()-1)*p.e1()*(tmp2 +p.e3() * p.e3())),
		(2*((p.e1()-1) * (p.e1()-1)+p.e2() * p.e2()-1)*p.e2()*(tmp1 +p.e3() * p.e3()) +
		2*((p.e1()+1) * (p.e1()+1)+p.e2() * p.e2()-1)*p.e2()*(tmp2 +p.e3() * p.e3())),
		(2*p.e3()*( tmp1+p.e3() * p.e3())+2*p.e3()*( tmp2+p.e3() * p.e3())));
	return v;
}



================================================================================
FILE: src/chap2/ex3/hpindex.cpp
================================================================================
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// Copyright 2007, Daniel Fontijne, University of Amsterdam -- fontijne@science.uva.nl

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#pragma warning(disable : 4312 4311 4244)

#ifdef WIN32
#include <windows.h>
#endif

#if defined (__APPLE__) || defined (OSX)
	#include <OpenGL/gl.h>
	#include <OpenGL/glext.h>
	#include <OpenGL/glu.h>
	#include <GLUT/glut.h>
#else
	#include <GL/gl.h>
	#include <GL/glut.h>
#endif

#include "fields.h"
#include "main.h"
#include "render.h"

static int ncube=0;

const double leps = 1e-09;

const double seps = 1e-09;

static float gLineSing;
static float g_lrefine=0.1f;

void zNormalize(const vector &v, vector &n, float &l) {
	l = _Float(norm_e(v));
	if (l > 10e-9f)
		n = v * (1.0f/ l);
	else {
	  //	printf("l %g\n",l);
		n = v;
		l = 0.0f;
	}
}

// Store data for surface fields
static vector* Dvf[6]; // Save the vector field over one cube to display it later
static int* Rvf[6]; // Note which pieces are refined so we won't display them
static vector* RDvf[1000]; // Overflow fields - caution, fixed sized array!
static int sRDvf[1000]; // How big is each field?
static int nRDvf; // Keep track of current field
static vector Dcenter; // center of the cube selected
static float Dlength; // Radius of sphere 

// Store data for line fields
const int max_sampsize = 100;
static vector Dpvf[6][4][max_sampsize]; // Save the project vector fields - caution, fixed sized array!
static int Rpvf[6][4][max_sampsize]; // Note which pieces are refined so we won't display them
static vector* RDpvf[6][1000]; // Overflow fields - caution, fixed size array!
static int sRDpvf[6][1000]; // How big is each field?
static int nRDpvf[6];

int refineFace(const vector &p, const vector &v1, const vector &v2, 
	       const int gsi, trivector &sum3d, 
	       vector & (*evalFunc)(const vector &p, vector &v),
	       int adap) {

	vector *vf; // normalized vector field evaluations are stored in here
	float *vfs; // the sizes of the original vector field evaluations are stored in here
	int nbvf = 0;
	float gs = (float)gsi;
	int i1, i2, vfIdx;
	vector cp; // current position
	vector v, *cvf; 

	nbvf = ((gsi+1) * (gsi+1));
	vf = new vector[nbvf];
	vfs = new float[nbvf];

	if ( ncube == g_Dcube ) {
	  if (sRDvf[nRDvf] < nbvf) {
	    if (RDvf[nRDvf]) delete[] RDvf[nRDvf];
	    RDvf[nRDvf] = new vector[nbvf];
	    sRDvf[nRDvf] = nbvf;
	  }
	}

	// evaluate the vector field over the entire face
	for (i1 = 0; i1 <= gsi; i1++) {
		for (i2 = 0; i2 <= gsi; i2++) {
		  float dummy;
			vfIdx = i1 * (gsi + 1) + i2;
			// compute position; evaluate
			cp = p +  v1 * ((float)i1 / gs) +
			  v2 * ((float)i2 / gs);
			evalFunc(cp, v);

			// normalize
			zNormalize(v, vf[vfIdx], dummy);
			if ( g_Dcube == ncube ) {
			  RDvf[nRDvf][vfIdx] = vf[vfIdx];
			}
		}
	}


	if ( g_Dcube == ncube ) {
	  nRDvf++;
	}

	// sum over face to compute 3d sum
	sum3d.set(); // sum3d = 0
	for (i1 = 0; i1 < gsi; i1++) {
		for (i2 = 0; i2 < gsi; i2++) {
			cvf = vf + i1 * (gsi + 1) + i2; // just a pointer to the current location in the face

			trivector a = _trivector(cvf[0] ^ cvf[gsi + 2] ^ cvf[gsi + 1]);
			trivector b = _trivector(cvf[0] ^ cvf[1] ^ cvf[gsi + 2]);
			if ( adap > 0 &&
			     (fabs(a.e1e2e3()) > g_refine ||
			      fabs(b.e1e2e3()) > g_refine )) {
			  trivector tmpsum3d;

//			  printf("refineFace: refining %d (%d)\n",ncube,adap);
			  float igs = 1.0f / gs;
			  cp = _vector(p + v1 * (float)i1 * igs + v2 * (float)i2 * igs);
			  refineFace(cp, _vector(v1 * igs), _vector(v2 * igs), gsi,  tmpsum3d, evalFunc, adap-1);
			  sum3d += tmpsum3d;
			} else {
			  sum3d += a+b;
			}
			if (0 && ncube == g_Dcube) {
//			  printf("%d: vol %g %g\n", ncube, a.e1e2e3(), b.e1e2e3()); 
			}
		}
	}

	delete[] vf;
	delete[] vfs;
	return 0;
}

int sumFace(const vector &p, const vector &v1, const vector &v2, 
	    const int gsi, trivector &sum3d,
	    vector & (*evalFunc)(const vector &p, vector &v), 
	    float& maxVfs, float& minVfs,
	    int depth, int maxDepth, int Dface, int adap) {

	static vector *vf; // normalized vector field evaluations are stored in here
	static float *vfs; // the sizes of the original vector field evaluations are stored in here
	static vector *pvf[4]; // projected normalized (edge) vector field evaluations are stored in here
	static float *pvfs[4]; // todo: explain what is stored here
	trivector sum3dUR; // keep track of unrefined sum
	static int nbvf = 0;
	float gs = (float)gsi;
	int i, i1, i2, vfIdx;
	vector cp; // current position
	vector v;
	bivector face = _bivector(v1 ^ v2);
	bivector faceInv = _bivector(inverse(face));
	vector *cvf, pv; 
	int rf; // true if we refine a face

	//	printf("Initially: minVfs = %g, maxVfs = %g\n",minVfs,maxVfs);
	// make sure we have enough memory to store vector field evaluations
	if ((gsi+1) * (gsi+1) > nbvf) {
		nbvf = ((gsi+1) * (gsi+1));
		if (vf) delete[] vf; vf = new vector[nbvf];
		for (i=0; i<6; i++) {
		  if (Dvf[i]) delete[] Dvf[i]; Dvf[i] = new vector[nbvf];
		  if (Rvf[i]) delete[] Rvf[i]; Rvf[i] = new int[nbvf];
		}
		vfs = (float*)realloc(vfs, sizeof(float) * nbvf);
		for (i = 0; i < 4; i++) {
			if (pvf[i]) delete[] pvf[i]; pvf[i] = new vector[gsi + 1];
			pvfs[i]  = (float*)realloc(pvfs[i], sizeof(float) * (gsi + 1));
		}
	}

	// evaluate the vector field over the entire face
	for (i1 = 0; i1 <= gsi; i1++) {
		for (i2 = 0; i2 <= gsi; i2++) {
			vfIdx = i1 * (gsi + 1) + i2;
			// compute position; evaluate
			float igs = 1.0f / gs;
			cp = _vector(p + v1 * (float)i1 * igs + v2 * (float)i2 * igs);
			evalFunc(cp, v);

			// normalize
			zNormalize(v, vf[vfIdx], vfs[vfIdx]);

			// Save values if we want to display this cube's field
			if ( g_Dcube == ncube && adap == g_adap) {
			  Dvf[Dface][vfIdx] = vf[vfIdx];
			}

			// track minimum and maximum field value
			if (!(i1 || i2)) {
			  minVfs = maxVfs = vfs[vfIdx];
			  //			  printf("init minVfs, maxVfs, %g\n",minVfs);
			}
			else {
				if (vfs[vfIdx] < minVfs) {
				  minVfs = vfs[vfIdx];
				  //				  printf("update minVfs %g\n",minVfs);
				} else if (vfs[vfIdx] > maxVfs) {
				  maxVfs = vfs[vfIdx];
				  //				  printf("update maxVfs %g\n",maxVfs);
				}
			}
		}
	}

	// sum over face to compute 3d sum
	sum3d.set(); // sum3d = 0;
	sum3dUR.set (); // sum3dUR = 0;
	rf = 0;
	for (i1 = 0; i1 < gsi; i1++) {
		for (i2 = 0; i2 < gsi; i2++) {
			cvf = vf + i1 * (gsi + 1) + i2; // just a pointer to the current location in the face

			trivector a = _trivector(cvf[0] ^ cvf[gsi + 2] ^ cvf[gsi + 1]);
			trivector b = _trivector(cvf[0] ^ cvf[1] ^ cvf[gsi + 2]);
			if ( adap > 0 &&
			     (fabs(a.e1e2e3()) > g_refine ||
			      fabs(b.e1e2e3()) > g_refine )) {
			  trivector tmpsum3d;
			  rf = 1;
			  //printf("sumFace: refining %d (%d) %d, depth %d, %g %g\n",ncube,adap,gsi,depth,(a[GRADE3])[0],(b[GRADE3])[0]);
			  float igs = 1.0f / gs;
			  cp = p + v1 * (float)i1 * igs + v2 * (float)i2 * igs;

			  refineFace(cp, _vector(v1 * igs), _vector(v2 * igs), gsi, tmpsum3d, evalFunc, adap-1);
			  //printf("%g vs %g\n",((c=a+b)[GRADE3])[0], (tmpsum3d[GRADE3])[0]);
			  sum3d += tmpsum3d;
			  sum3dUR += a+b;

			  // Note if we refine a square
			  if ( g_Dcube == ncube ) {
			    Rvf[Dface][i1*(gsi+1) +i2] = 1;
			  }
			} else {
			  sum3d += a+b;
			  sum3dUR += a+b;

			  // Note if we don't refine a square
			  if ( g_Dcube == ncube ) {
			    Rvf[Dface][i1*(gsi+1) +i2] = 0;
			  }
			}
			if (0 && ncube == g_Dcube) {
			  printf("%d: vol %g %g\n", ncube, a.e1e2e3(), b.e1e2e3()); 
			}
		}
	}
	if ( rf && 0 ) {
	  printf("Refined vs unrefined (%d): %g vs %g (%g)\n",ncube, sum3d.e1e2e3(), sum3dUR.e1e2e3(), sum3d.e1e2e3()-sum3dUR.e1e2e3());
	}

	if ( rf ) {
	  extern int g_refines;
	  g_refines++;
	}
	return 0;
}

static trivector g_sum2dUR; // Used to keep track of unrefined sum
static int g_2drf; // Used to keep track of whether we refine 2d

/*
 *----------------------------------------------------------------------
 *  Function:  sumEdge
 *	Sample an edge, projecting each sample onto the face.  Sum
 *  bivectors formed of adjacent projected vectors.  Also, test the
 *  positive/negative aspect of the edge (to be used elswhere for
 *  surface singularity detection).
 *----------------------------------------------------------------------
 */
bivector sumEdge(const vector& p, const vector& v, const int gsi,
	     vector & (*evalFunc)(const vector &p, vector &v), 
	     float& minV, float& maxV,
	     const bivector &face, const bivector &faceInv, 
	     int& mf, int& pf, int Dface, int Dedge, int adap) {
  int i1;
  float gs=(float)gsi;
  float tmpFloat;
  vector pvf[1000];

  //  printf("sumEdge: Dface %d, Dedge %d\n",Dface,Dedge);

  if ( gsi >= 1000 ) {
    printf("sumEdge: %d samples on edge is too many.  Exiting.\n", gsi);
    exit(1);
  }

  if ( ncube == g_Dcube && g_adap != adap ) {
    if (sRDpvf[Dface][nRDpvf[Dface]] < gsi+1) {
      if (RDpvf[Dface][nRDpvf[Dface]]) delete[] RDpvf[Dface][nRDpvf[Dface]];
      RDpvf[Dface][nRDpvf[Dface]] = new vector[gsi+1];
      sRDpvf[Dface][nRDpvf[Dface]] = gsi+1;
    }
  }


  float tmpMin=100;
  for (i1=0; i1 <= gsi; i1++) {
	  float igs = 1.0f / gs;
    vector cp = _vector(p + v*(float)i1 * igs);
    vector tmpv,tmpv2;
    evalFunc(cp, tmpv);
    zNormalize(tmpv, tmpv2, tmpFloat);
    if ( i1==0 ) {
      minV = maxV = tmpFloat;
    } else {
      if ( minV > tmpFloat ) minV = tmpFloat;
      if ( maxV < tmpFloat ) maxV = tmpFloat;
    }
    tmpv = _vector((tmpv<<face)<<faceInv);
    zNormalize(tmpv, pvf[i1], tmpFloat);
    if ( tmpMin > tmpFloat ) tmpMin = tmpFloat;
    if ( ncube == g_Dcube  &&  adap == g_adap ) {
      Dpvf[Dface][Dedge][i1] = pvf[i1];
    } else if ( ncube == g_Dcube ) {
      RDpvf[Dface][nRDpvf[Dface]][i1] = pvf[i1];
    }
  }

  if ( 0 && tmpMin < 0.01 ) {
//    printf("sumEdge %d: tmpMin = %g\n",ncube,tmpMin);
  }

  if ( g_Dcube == ncube && adap != g_adap ) {
    nRDpvf[Dface]++;
  }

  bivector sum2d;
  tmpMin = 1000.0f;
  for (i1=0; i1<gsi; i1++) {
    bivector a = _bivector(pvf[i1] ^ pvf[i1+1]);
    float b = _Float(pvf[i1]<<pvf[i1+1]);
    float tmpD= b;
    if ( tmpD < tmpMin ) {
      tmpMin = tmpD;
    }
    if ( tmpD < 0 ) {
      //      printf("tmpD %g, %d.%d, (%g,%g,%g).(%g,%g,%g)\n",tmpD,i1,i1+1,
      //	     ((pvf[i1])[GRADE1])[0],((pvf[i1])[GRADE1])[1],((pvf[i1])[GRADE1])[2],
      //	     ((pvf[i1+1])[GRADE1])[0],((pvf[i1+1])[GRADE1])[1],((pvf[i1+1])[GRADE1])[2]);
    }
    if ( adap > 0  &&  (fabs(_Float(a % a)) > g_lrefine*g_lrefine ||
			tmpD < 0.5) ) {
      float tmpMinV, tmpMaxV;
	  float igs = 1.0f / gs;
      vector cp = _vector(p + v * (float)i1 * igs);
      bivector tmpsum2d = sumEdge(cp, _vector(v * igs), gsi, evalFunc, tmpMinV, tmpMaxV, 
		      face, faceInv,mf,pf,Dface,Dedge,adap-1);
      if ( minV > tmpMinV ) minV = tmpMinV;
      if ( maxV < tmpMaxV ) maxV = tmpMaxV;
      sum2d += tmpsum2d;
      g_sum2dUR += a;
      g_2drf = 1;
      if ( g_Dcube == ncube ) {
	Rpvf[Dface][Dedge][i1] = 1;
      }
    } else {
      sum2d += a;
      g_sum2dUR += a;
      if ( g_Dcube == ncube ) {
	Rpvf[Dface][Dedge][i1] = 0;
      }
    }
  }

  if ( tmpMin < 0 ) {
    //    printf("sumEdge %d (%d): min(tmpD) = %g\n",ncube,adap,tmpMin);
  }

  // test for surface singularity....
  for (i1 = 0; i1 <= gsi; i1++) {
    if (_Float(pvf[i1] % v) < 0) mf = 1;
    else pf = 1;
  }
  return sum2d;
}

void sumEdges(const vector &p, const vector &v1, const vector &v2, 
	    const int gsi, int &lineSing, int &surfSing,
	    vector & (*evalFunc)(const vector &p, vector &v), int depth, 
	    int maxDepth, int Dface, int adap) {

	bivector face = _bivector(v1 ^ v2);
	bivector faceInv = _bivector(inverse(face));
	bivector sum2d;
	int mf,pf;
	float minV,maxV;

	mf = pf = 0;
	g_sum2dUR.set(); 
	g_2drf = 0;
	sum2d = sumEdge(p, v1, gsi, evalFunc, minV, maxV, 
			face, faceInv,mf,pf,Dface,0,adap);
	if ( mf==1 && pf==1 ) {
	  if ( minV < seps  ||  maxV/minV > g_sratio || !g_falseSurfSing) {
	    //	    printf("surfSing A %d: %g < %g || %g/%g=%g > %g\n",ncube,
	    //		   minV,seps,maxV,minV,maxV/minV,g_sratio);
	    surfSing = 1;
	  }
	}

	mf = pf = 0;
	sum2d += sumEdge(_vector(p+v1),v2, gsi, evalFunc, minV, maxV, 
			 face, faceInv,mf,pf,Dface,1,adap);
	if ( mf==1 && pf==1 ) {
	  if ( minV < seps  ||  maxV/minV > g_sratio || !g_falseSurfSing) {
	    //	    printf("surfSing B %d: %g < %g || %g/%g=%g > %g\n",ncube,
	    //		   minV,seps,maxV,minV,maxV/minV,g_sratio);
	    surfSing = 1;
	  }
	}

	mf = pf = 0;
	sum2d += sumEdge(_vector(p+v1+v2), _vector(-v1), gsi, evalFunc, minV, maxV, 
			 face, faceInv,mf,pf,Dface,2,adap);
	if ( mf==1 && pf==1 ) {
	  if ( minV < seps  ||  maxV/minV > g_sratio || !g_falseSurfSing) {
	    //	    printf("surfSing C %d: %g < %g || %g/%g=%g > %g\n",ncube,
	    //		   minV,seps,maxV,minV,maxV/minV,g_sratio);
	    surfSing = 1;
	  }
	}

	mf = pf = 0;
	sum2d += sumEdge(_vector(p+v2), _vector(-v2), gsi, evalFunc, minV, maxV, 
			 face, faceInv,mf,pf,Dface,3,adap);
	if ( mf==1 && pf==1 ) {
	  if ( minV < seps  ||  maxV/minV > g_sratio || !g_falseSurfSing) {
	    //	    printf("surfSing D %d: %g < %g || %g/%g=%g > %g\n",ncube,
	    //		   minV,seps,maxV,minV,maxV/minV,g_sratio);
	    surfSing = 1;
	  }
	}


	// normalize 2d sum, set lineSing
	sum2d *= (1.0f / (3.1415f * 2.0f));

  if ( g_2drf ) {
    g_sum2dUR *= (1.0f / (3.1415f * 2.0f));
    //    printf("Refined vs unrefined 2d (%d): %g vs %g\n",
    //	   ncube, 
    //	   sqrt(fabs((sum2d % sum2d).scalar())), 
    //   sqrt(fabs((g_sum2dUR % g_sum2dUR).scalar())));
  }

	gLineSing = _Float(norm_e(sum2d)); //sqrt(fabs(_Float(sum2d % sum2d)));
	if (gLineSing > g_lsing) {
	  lineSing = 1;
	} else {
	  lineSing =0;
	}
	//	fprintf(stderr,"line sing is %g  %d\n",gLineSing,lineSing);
}

int sumCube(const vector &p, const vector dir[3],
		 const int gsi, int &pointSing, int &lineSing, int &surfSing,
		 vector & (*evalFunc)(const vector &p, vector &v), int depth, int maxDepth) {

	trivector sum3d;
	int lsTmp = 0, sfTmp = 0;

	bivector sum2d;
	trivector tmpsum3d;
	vector v1, v2, cp;
	ncube++;

	if (ncube == g_Dcube) {
	  if ( g_USphere ) {
	    Dcenter = _vector(0.0f*p);
	    Dlength=1.0f;
	  } else {
	    Dcenter = _vector(p + 0.5f * dir[0] + 0.5f * dir[1] + 0.5f * dir[2]);
	    if ( g_ISphere ) {
	      Dlength = _Float(norm_e(0.5f * dir[0]));
	    } else {
	      Dlength = _Float(norm_e(0.5f * dir[0] + 0.5f * dir[1] + 0.5f * dir[2]));
	    }
	  }
	}
	// these tables are used to evaluate all 6 faces of the cube
	static const int dirs[6][2] = // specifies which basis vectors (from 'dir') to use for each face
	{
		{0, 1}, // dir0 & dir1
		{2, 1}, // dir2 & dir1
		{0, 1}, // -dir0 & dir1
		{2, 1}, // -dir2 & dir1
		{0, 2}, // dir0 & dir2
		{0, 2}  // dir0 & -dir2
	};
	static const float signs[6][2] = // specifies the sign of the basis vector
	{
		{1, 1},
		{1, 1},
		{-1, 1},
		{-1, 1},
		{1, 1},
		{1, -1}
	};
	static const float offsets[6][3] = // specifies offset from p
	{
		{0, 0, 0},
		{1, 0, 0},
		{1, 0, 1},
		{0, 0, 1},
		{0, 1, 0},
		{0, 0, 1}
	};

	int i;

	// visit each of the 6 faces, compute the 3d sum, line & surface singularities
	for (i = 0; i < 6; i++) {
		float maxL,minL;
		int lsing=0,ssing=0;

		cp = _vector(p + offsets[i][0] * dir[0] + offsets[i][1] * dir[1] + 
		  offsets[i][2] * dir[2]);
		v1 = signs[i][0] * dir[dirs[i][0]];
		v2 = signs[i][1] * dir[dirs[i][1]];
		tmpsum3d.set(); // tmpsum3d = 0
		sumFace(cp, v1, v2, gsi, tmpsum3d, evalFunc, maxL, minL,
			depth, maxDepth, i, g_adap);
		sum3d += tmpsum3d;

		sumEdges(cp, v1, v2, gsi, lsing, ssing,
			 evalFunc, depth, maxDepth, i, g_adap);
		// test for false line singularities
		if ( lsing ) {
		  //		  fprintf(stderr,"%d: %g<?%g, %g/%g=%g >? %g\n",
		  //  lsing,minL,leps,maxL,minL,maxL/minL,g_lratio);
		  if ( minL < leps  ||  maxL/minL > g_lratio  ||  !g_falseLineSing ) {
//		    printf("lineSing %d %d/%d %g\n",ncube, depth,maxDepth, gLineSing);
		    lineSing = 1;
		  } 
		}
		if ( ssing ) {
		  surfSing = 1;
		}
	}

	// normalize sum, detect point singularity
	sum3d *= 1.0f / (6.0f * 4.0f * 3.1415f / 3.0f);

	if ( g_Dcube == ncube  ||  _Float(norm_e(sum3d)) > 0.1 ) {
		vector _tmp = _vector(dir[0]+dir[1]+dir[2]);
	  const float* c = p.getC(vector_e1_e2_e3);
	  const float* cc = _tmp.getC(vector_e1_e2_e3);
//	printf("%d: %g %d/%d (%g %g %g) (%g %g %g)\n",ncube, _Float(norm_e(sum3d)),depth,maxDepth,c[0],c[1],c[2],c[0]+cc[0],c[1]+cc[1],c[2]+cc[2]);
	}
	if ( _Float(norm_e2(sum3d % sum3d)) > 1.0f ) {
			  printf("Point Sing > 1 (%g) %d\n",
				 _Float(norm_e(sum3d)),depth);
	}
	if ( g_Dcube == ncube ) {
	  g_hpvalue = sum3d.e1e2e3();
	}
	pointSing = (_Float(norm_e2(sum3d)) > g_psing*g_psing);

	return 0;
}


/*
Finds & draws singularities
  */
int	findSingularities(const vector &p, const vector dir[3],
		 const int gsi, vector & (*evalFunc)(const vector &p, vector &v), int depth, int maxDepth) {
	int pointSing, lineSing, surfSing, sing;

	if ( depth == 0 ) {
	  ncube = 0;
	  nRDvf = 0;
	  nRDpvf[0] = nRDpvf[1] = nRDpvf[2] = nRDpvf[3] = nRDpvf[4] = nRDpvf[5] = 0;
	}
	g_boxes++;

	// evaluate current cube
	pointSing = lineSing = surfSing = 0;
	sumCube(p, dir, gsi, pointSing, lineSing, surfSing, evalFunc, depth, maxDepth);
	sing = pointSing | lineSing | surfSing;
	if ( sing && 0) {
		printf("sing %d (%d/%d) %d|%d|%d\n",ncube,
	       depth,maxDepth, pointSing,lineSing,surfSing);
	}

	// OpenGL drawing code...
	if ((depth == maxDepth) || g_showOctree) {
		GLfloat cRed[4] = {1.0f, 0.0f, 0.0f, 1.0f};
		GLfloat cGreen[4] = {0.0f, 1.0f, 0.0f, 1.0f};
		GLfloat cBlue[4] = {0.0f, 0.0f, 1.0f, 1.0f};
		GLfloat cWhite[4] = {1.0f, 1.0f, 1.0f, 1.0f};
		GLfloat cBlack[4] = {0.0f, 0.0f, 0.0f, 0.0f};
		GLfloat *color;
		if (pointSing) color = cRed; // point singularity = red
		else if (lineSing) color = cGreen; // line singularity = green
		else if (surfSing) color = cBlue; // surface singularity = blue
		else color = cBlack;
		glColor3fv(color);
		glMaterialfv(GL_FRONT, GL_AMBIENT, color);
		glMaterialfv(GL_FRONT, GL_DIFFUSE, color);

		glPolygonMode(GL_FRONT_AND_BACK, 
			      (sing  &&  depth == maxDepth) ? GL_FILL : GL_LINE);
		if (sing||g_bottom) {
			drawCube(p, g_cubeSize / (float)(1 << depth));
		}
	}

	// end of recursion
	if (depth == maxDepth) return 0;

	// if there was a singularity: descend down octree
	if (sing) {
		int i;
		// divide the size of the cube by two
		vector newDir[3], newP;
		for (i = 0; i < 3; i++)
			newDir[i] = _vector(0.5f * dir[i]);

		// go though all permutations of adding or not adding one of the 3 basis directions.
		// Descend octree
		for (i = 0; i < (1 << 3); i++) {
			newP = _vector(p + 
			(float)((i&1) != 0) * newDir[0] + 
			(float)((i&2) != 0) * newDir[1] + 
			(float)((i&4) != 0) * newDir[2]);
			//			printf("subcube %d:%d\n",depth,i);
			findSingularities(newP, newDir, gsi, evalFunc, depth + 1, maxDepth);
		}
	}

	return 0;
}


// type==0 => lines, type==1 => positive, type==2 => negative
void drawSphere(int gs, int type) {
  //  static float origin[4] = {0.0f, 0.0f, 0.0f, 1.0f};
  int face;
  int i,i1,i2;
  int vfIdx;
  static GLfloat cRed[4] = {1.0f, 0.0f, 0.0f, 1.0f};
  static GLfloat cBlue[4] = {0.0f, 0.0f, 1.0f, 1.0f};

  switch (type) {
  case 0:
    glBegin(GL_LINES);
    glColor3fv(lineColor);
    for (face = 0; face<6; face++) {
      for (i1=0; i1<=gs; i1++) {
	for (i2=0; i2<=gs; i2++) {
	  glVertex3fv(Dcenter.getC(vector_e1_e2_e3));
	  vfIdx = i1 * (gs + 1) + i2;
	  glVertex3fv(_vector(Dlength*Dvf[face][vfIdx]+Dcenter).getC(vector_e1_e2_e3));
	}
      }
    }
    for (i=0; i<nRDvf; i++) {
      for (i1=0; i1<=gs; i1++) {
	for (i2=0; i2<=gs; i2++) {
	  glVertex3fv(Dcenter.getC(vector_e1_e2_e3));
	  vfIdx = i1 * (gs + 1) + i2;
	  glVertex3fv(_vector(Dlength*RDvf[i][vfIdx]+Dcenter).getC(vector_e1_e2_e3));
	}
      }
    }
    glEnd();
    break;
  case 1:
    glColor3fv(cRed);
    glMaterialfv(GL_FRONT, GL_AMBIENT, cRed);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, cRed);

    glDisable(GL_CULL_FACE);
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL );
    glBegin(GL_TRIANGLES);
    for (face = 0; face<6; face++) {
      for (i1=0; i1<gs; i1++) {
	for (i2=0; i2<gs; i2++) {
	  vector* cvf = Dvf[face] + i1 * (gs + 1) + i2; 
	  //		sum3d += (cvf[0] ^ cvf[gsi + 2] ^ cvf[gsi + 1]) + 
	  //		  (cvf[0] ^ cvf[1] ^ cvf[gsi + 2]);
	  if (!Rvf[face][i1*(gs+1) +i2] &&
	      _trivector(cvf[0] ^ cvf[gs + 2] ^ cvf[gs + 1]).e1e2e3() >= 0) {
	    glVertex3fv(_vector(Dlength*cvf[0]+Dcenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*cvf[gs+2]+Dcenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*cvf[gs+1]+Dcenter).getC(vector_e1_e2_e3));
	  }

	  if (!Rvf[face][i1*(gs+1) +i2] &&
	      _trivector(cvf[0] ^ cvf[1] ^ cvf[gs + 2]).e1e2e3() >= 0 ) {
	    glVertex3fv(_vector(Dlength*cvf[0]+Dcenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*cvf[1]+Dcenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*cvf[gs+2]+Dcenter).getC(vector_e1_e2_e3));
	  }
	}
      }
    }
    for (i=0; i<nRDvf; i++) {
      for (i1=0; i1<gs; i1++) {
	for (i2=0; i2<gs; i2++) {
	  vector* cvf = RDvf[i] + i1 * (gs + 1) + i2; 
	  //		sum3d += (cvf[0] ^ cvf[gsi + 2] ^ cvf[gsi + 1]) + 
	  //		  (cvf[0] ^ cvf[1] ^ cvf[gsi + 2]);
	  if ( _trivector(cvf[0] ^ cvf[gs + 2] ^ cvf[gs + 1]).e1e2e3() >= 0.0f ) {
	    glVertex3fv(_vector(Dlength*cvf[0]+Dcenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*cvf[gs+2]+Dcenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*cvf[gs+1]+Dcenter).getC(vector_e1_e2_e3));
	  }

	  if ( _trivector(cvf[0] ^ cvf[1] ^ cvf[gs + 2]).e1e2e3() >= 0.0f ) {
	    glVertex3fv(_vector(Dlength*cvf[0]+Dcenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*cvf[1]+Dcenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*cvf[gs+2]+Dcenter).getC(vector_e1_e2_e3));
	  }
	}
      }
    }
    glEnd();
    break;
  case 2:
    glColor3fv(cBlue);
    glMaterialfv(GL_FRONT, GL_AMBIENT, cBlue);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, cBlue);

    glDisable(GL_CULL_FACE);
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    glBegin(GL_TRIANGLES);
    for (face = 0; face<6; face++) {
      for (i1=0; i1<gs; i1++) {
	for (i2=0; i2<gs; i2++) {
	  vector* cvf = Dvf[face] + i1 * (gs + 1) + i2; 
	  //		sum3d += (cvf[0] ^ cvf[gs + 2] ^ cvf[gs + 1]) + 
	  //		  (cvf[0] ^ cvf[1] ^ cvf[gs + 2]);
	  if (!Rvf[face][i1*(gs+1) +i2] &&
	      _trivector(cvf[0] ^ cvf[gs + 2] ^ cvf[gs + 1]).e1e2e3() <= 0 ) {
	    glVertex3fv(_vector(Dlength*cvf[0]+Dcenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*cvf[gs+2]+Dcenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*cvf[gs+1]+Dcenter).getC(vector_e1_e2_e3));
	  } 

	  if (!Rvf[face][i1*(gs+1) +i2] &&
	      _trivector(cvf[0] ^ cvf[1] ^ cvf[gs + 2]).e1e2e3() <= 0 ) {
	    glVertex3fv(_vector(Dlength*cvf[0]+Dcenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*cvf[1]+Dcenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*cvf[gs+2]+Dcenter).getC(vector_e1_e2_e3));
	  }
	}
      }
    }
    for (i=0; i<nRDvf; i++) {
      for (i1=0; i1<gs; i1++) {
	for (i2=0; i2<gs; i2++) {
	  vector* cvf = RDvf[i] + i1 * (gs + 1) + i2; 
	  //		sum3d += (cvf[0] ^ cvf[gsi + 2] ^ cvf[gsi + 1]) + 
	  //		  (cvf[0] ^ cvf[1] ^ cvf[gsi + 2]);
	  if ( _trivector(cvf[0] ^ cvf[gs + 2] ^ cvf[gs + 1]).e1e2e3() < 0 ) {
	    glVertex3fv(_vector(Dlength*cvf[0]+Dcenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*cvf[gs+2]+Dcenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*cvf[gs+1]+Dcenter).getC(vector_e1_e2_e3));
	  }

	  if ( _trivector(cvf[0] ^ cvf[1] ^ cvf[gs + 2]).e1e2e3() < 0 ) {
	    glVertex3fv(_vector(Dlength*cvf[0]+Dcenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*cvf[1]+Dcenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*cvf[gs+2]+Dcenter).getC(vector_e1_e2_e3));
	  }
	}
      }
    }
    glEnd();
    break;
  }
}

// type==0 => lines, type==1 => positive, type==2 => negative
void drawCirc(int gs, int type) {
  //  static float origin[4] = {0.0f, 0.0f, 0.0f, 1.0f};
  int face;
  int i,i1;
  static GLfloat cRed[4] = {1.0f, 0.0f, 0.0f, 1.0f};
  static GLfloat cBlue[4] = {0.0f, 0.0f, 1.0f, 1.0f};
  static int dirs[6][3] = {
    {0,0,-1},
    {1,0,0},
    {0,0,1},
    {-1,0,0},
    {0,1,0},
    {0,-1,0}
  };

  switch (type) {
  case 0:
    glBegin(GL_LINES);
    glColor3fv(lineColor);
    for (face = 0; face<6; face++) {
      vector oCenter;
      oCenter = _vector(Dcenter+Dlength*dirs[face][0]*e1 +
	Dlength*dirs[face][1]*e2 +
	Dlength*dirs[face][2]*e3);
      for (i1=0; i1<=gs; i1++) {
	glVertex3fv(oCenter.getC(vector_e1_e2_e3));
	glVertex3fv(_vector(Dlength*Dpvf[face][0][i1]+oCenter).getC(vector_e1_e2_e3));
	glVertex3fv(oCenter.getC(vector_e1_e2_e3));
	glVertex3fv(_vector(Dlength*Dpvf[face][1][i1]+oCenter).getC(vector_e1_e2_e3));
	glVertex3fv(oCenter.getC(vector_e1_e2_e3));
	glVertex3fv(_vector(Dlength*Dpvf[face][2][i1]+oCenter).getC(vector_e1_e2_e3));
	glVertex3fv(oCenter.getC(vector_e1_e2_e3));
	glVertex3fv(_vector(Dlength*Dpvf[face][3][i1]+oCenter).getC(vector_e1_e2_e3));
      }
#if 1
      for (i=0; i<nRDpvf[face]; i++) {
	for (i1=0; i1<=gs; i1++) {
	  glVertex3fv(oCenter.getC(vector_e1_e2_e3));
	  glVertex3fv(_vector(Dlength*RDpvf[face][i][i1]+oCenter).getC(vector_e1_e2_e3));
	}
      }
#endif
    }
    glEnd();
    break;
  case 1:
    glColor3fv(cRed);
    glMaterialfv(GL_FRONT, GL_AMBIENT, cRed);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, cRed);

    glDisable(GL_CULL_FACE);
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL );
    glBegin(GL_TRIANGLES);
    for (face = 0; face<6; face++) {
      vector up = _vector(Dlength*dirs[face][0]*e1 +
	Dlength*dirs[face][1]*e2 +
	Dlength*dirs[face][2]*e3);
      vector oCenter = _vector(Dcenter+up);
      bivector faceB = _bivector(dual(up));

      for (i1=0; i1<gs; i1++) {
	if ( !Rpvf[face][0][i1] &&
	     _Float(faceB<<(Dpvf[face][0][i1]^Dpvf[face][0][i1+1])) >= 0 ) {
	    glVertex3fv((oCenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*Dpvf[face][0][i1]+oCenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*Dpvf[face][0][i1+1]+oCenter).getC(vector_e1_e2_e3));
	}

	if ( !Rpvf[face][1][i1] &&
	     _Float(faceB<<(Dpvf[face][1][i1]^Dpvf[face][1][i1+1])) >= 0 ) {
	    glVertex3fv((oCenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*Dpvf[face][1][i1]+oCenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*Dpvf[face][1][i1+1]+oCenter).getC(vector_e1_e2_e3));
	}

	if ( !Rpvf[face][2][i1] &&
	     _Float(faceB<<(Dpvf[face][2][i1]^Dpvf[face][2][i1+1])) >= 0 ) {
	    glVertex3fv((oCenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*Dpvf[face][2][i1]+oCenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*Dpvf[face][2][i1+1]+oCenter).getC(vector_e1_e2_e3));
	}

	if ( !Rpvf[face][3][i1] &&
	     _Float(faceB<<(Dpvf[face][3][i1]^Dpvf[face][3][i1+1])) >= 0 ) {
	    glVertex3fv((oCenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*Dpvf[face][3][i1]+oCenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*Dpvf[face][3][i1+1]+oCenter).getC(vector_e1_e2_e3));
	}
      }
#if 1
      for (i=0; i<nRDpvf[face]; i++) {
	for (i1=0; i1<gs; i1++) {
	  if (_Float(faceB<<(RDpvf[face][i][i1]^RDpvf[face][i][i1+1])) >= 0 ) {
	    glVertex3fv(oCenter.getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*RDpvf[face][i][i1]+oCenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*RDpvf[face][i][i1+1]+oCenter).getC(vector_e1_e2_e3));
	  }
	}
      }
#endif
    }
    glEnd();
    break;
  case 2:
    glColor3fv(cBlue);
    glMaterialfv(GL_FRONT, GL_AMBIENT, cBlue);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, cBlue);

    glDisable(GL_CULL_FACE);
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    glBegin(GL_TRIANGLES);
    for (face = 0; face<6; face++) {
      vector up= _vector(Dlength*dirs[face][0]*e1 +
	Dlength*dirs[face][1]*e2 +
	Dlength*dirs[face][2]*e3);
      vector oCenter = _vector(Dcenter+.995f*up);
      bivector faceB = _bivector(dual(up));

      for (i1=0; i1<gs; i1++) {
	if (  !Rpvf[face][0][i1] &&
	      _Float(faceB<<(Dpvf[face][0][i1]^Dpvf[face][0][i1+1])) < 0 ) {
	    glVertex3fv((oCenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*Dpvf[face][0][i1]+oCenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*Dpvf[face][0][i1+1]+oCenter).getC(vector_e1_e2_e3));
	}

	if ( !Rpvf[face][1][i1] &&
	     _Float(faceB<<(Dpvf[face][1][i1]^Dpvf[face][1][i1+1])) < 0 ) {
	    glVertex3fv((oCenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*Dpvf[face][1][i1]+oCenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*Dpvf[face][1][i1+1]+oCenter).getC(vector_e1_e2_e3));
	}

	if ( !Rpvf[face][2][i1] &&
	     _Float(faceB<<(Dpvf[face][2][i1]^Dpvf[face][2][i1+1])) < 0 ) {
	    glVertex3fv((oCenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*Dpvf[face][2][i1]+oCenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*Dpvf[face][2][i1+1]+oCenter).getC(vector_e1_e2_e3));
	}

	if ( !Rpvf[face][3][i1] &&
	     _Float(faceB<<(Dpvf[face][3][i1]^Dpvf[face][3][i1+1])) < 0 ) {
	    glVertex3fv((oCenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*Dpvf[face][3][i1]+oCenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*Dpvf[face][3][i1+1]+oCenter).getC(vector_e1_e2_e3));
	}
      }
#if 1
      for (i=0; i<nRDpvf[face]; i++) {
	for (i1=0; i1<gs; i1++) {
	  if (_Float(faceB<<(RDpvf[face][i][i1]^RDpvf[face][i][i1+1])) < 0 ) {
	    glVertex3fv(oCenter.getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*RDpvf[face][i][i1]+oCenter).getC(vector_e1_e2_e3));
	    glVertex3fv(_vector(Dlength*RDpvf[face][i][i1+1]+oCenter).getC(vector_e1_e2_e3));
	  }
	}
      }
#endif
    }

    glEnd();
    break;
  }
}


================================================================================
FILE: src/chap2/ex3/main.cpp
================================================================================
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// Copyright 2007, Daniel Fontijne, University of Amsterdam -- fontijne@science.uva.nl

/*
Gaigen 2 HP Index

Detects singularities in vector fields.
(C) 2001-2006 Daniel Fontijne - University of Amsterdam & Stephen Mann - University of Waterloo
Algorithm and original matlab code by Stephen Mann & Alyn Rockwood

*/

#include <stdio.h>
#include <stdlib.h>


#ifdef WIN32
#include <windows.h>
#endif

#if defined (__APPLE__) || defined (OSX)
	#include <OpenGL/gl.h>
	#include <OpenGL/glext.h>
	#include <OpenGL/glu.h>
	#include <GLUT/glut.h>
#else
	#include <GL/gl.h>
	#include <GL/glut.h>
#endif

#include <stdio.h>
#include <stdlib.h>

#include <vector>
#include <string>

#include <libgasandbox/common.h>
#include <libgasandbox/gl_util.h>
#include <libgasandbox/glut_util.h>
#include <libgasandbox/e3ga_util.h>

#include "fields.h"
#include "render.h"

const char *WINDOW_TITLE = "Geometric Algebra, Chapter 2, Example 3: Vector Field Singularity Detection";

// GLUT state information 
int g_viewportWidth = 800;
int g_viewportHeight = 600;
int g_GLUTmenu;
// mouse position on last call to MouseButton() / MouseMotion()
e3ga::vector g_prevMousePos;
e3ga::rotor g_modelRotor(_rotor(1.0f));;
float g_modelDistance = 11.0f;
// when true, MouseMotion() will rotate the model
bool g_rotateModel = false;
bool g_rotateModelOutOfPlane = false;
bool g_translateModel = false;

// (FORMERLY-ui) controlled globals:
float g_cx=0.05f, g_cy=0.05f, g_cz=0.05f;
int g_showField = 0, g_showOctree = 0,  g_showResult = 1, g_unitField=0,
  g_bottom=0;
int g_gs = 8, g_maxDepth = 7;
int g_adap=0;
int g_vgs = 10;
float g_vectorSize = 1.0f;
float g_cubeSize = 5.0f;
float g_lratio = 10.0f;
float g_sratio = 10.0f;
float g_lsing = 0.10f;
float g_psing = 0.10f;
float g_refine = 0.10f;
float g_lrefine = 0.10f;
double g_lastTiming = 0.0f;
int g_boxes=0;
int g_refines=0;
int g_lineSing = 1;
int g_surfSing = 1;
int g_lighting = 1;
int g_falseLineSing = 1; 
int g_falseSurfSing=1;
int g_pushGo = 0;

int g_Dcube = 0;
int g_showSphere=1;
int g_showPSphere=1;
int g_showNSphere=1;
int g_showCirc=0;
int g_USphere=1;
int g_ISphere=0;
float g_hpvalue=0.0;

/* Constants used in vortex field */
float g_omega=1.0;
float g_gamma=1.0;
float g_Rcore=1.0;

float g_dx=0.;
float g_dy=0.;
float g_dz=1.;

// what function are we using currently 
e3ga::vector & (*g_evalFunc)(const e3ga::vector &p, e3ga::vector &v) = (e3ga::vector & (*)(const e3ga::vector &p, e3ga::vector &v))eight2;

// the fields (names + evaluation functions)
// The dull ones are commented out
struct fieldFunctionStruct {
		const char *fieldName;
		e3ga::vector & (*func)(const e3ga::vector &p, e3ga::vector &v);
} g_fieldFunctions[] = {
//{"constant", const3},
//{"vortex", vortex},
{"point", point3},
{"line", line3},
{"line (helix field)", helix3},
{"circle", circ3},
{"eight", eight2},
{"sphere", sphere3},
//{"testFunc3", testFunc3},
{"x^3*y^3*z^2", testFunc4},
//{"x^3+y^3+z^2", testFunc5},
//{"x^3+y^3+x^2", testFunc6},
{"x^3*y^3", testFunc7},
//{"Z^2/(Z+2)/(Z-4/5)", testFunc8},
//{"1/Z", testFunc9},
//{"x^3+y^3+z^3", testFunc10},
//{"x^4+y^4+z^4", testFunc11},
{"(x^2+y^2-z)^2 (cup)", testFunc12},
{"sphere union cyl", testFunc13},
{"sphere int cyl", testFunc14},
{"helix", testFunc15},
//{"double line", testFunc16},
//{"double point", testFunc16a},
//{"x^3/3 - xy^2 + z^2", testFunc17},
//{"x^3/3 - xy^2", testFunc18},
{NULL, NULL},
};


void display() {
	doIntelWarning(); // warn for possible problems with pciking on Intel graphics chipsets

	glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	
	glEnable(GL_DEPTH_TEST);

	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();

	glTranslatef(0, 0, -g_modelDistance);
	rotorGLMult(g_modelRotor);

	// all drawing code is inside render.cpp
	drawAll();

	glPopMatrix();

	{
		glMatrixMode(GL_PROJECTION);
		glPushMatrix();
		glLoadIdentity();
		glOrtho(0, g_viewportWidth, 0, g_viewportHeight, -100.0, 100.0);
		glMatrixMode(GL_MODELVIEW);
		glPushMatrix();
		glLoadIdentity();

		glColor3f(1.0, 0.0, 0.0);
		void *font = GLUT_BITMAP_HELVETICA_12;
		renderBitmapString(20, 80, font, "Left mouse button: rotate");
		renderBitmapString(20, 60, font, "Middle mouse button: select vector field");
		renderBitmapString(20, 40, font, "Right mouse button: translate");
		renderBitmapString(20, 20, font, "Detected singulaties are drawn in RED (points), GREEN (lines), BLUE (surfaces)");
		glPopMatrix();
		glMatrixMode(GL_PROJECTION);
		glPopMatrix();
		glMatrixMode(GL_MODELVIEW);
	}

	glutSwapBuffers();	
}

void reshape(GLint width, GLint height) {
	g_viewportWidth = width;
	g_viewportHeight = height;

	// setup projection & transform for the model:
	glViewport(0, 0, g_viewportWidth, g_viewportHeight);
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	const float screenWidth = 1600.0f;
	glFrustum(
		-(float)g_viewportWidth / screenWidth, (float)g_viewportWidth / screenWidth, 
		-(float)g_viewportHeight / screenWidth, (float)g_viewportHeight / screenWidth, 
		1.0, 100.0);
	
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();

	// redraw viewport
	glutPostRedisplay();	
}

e3ga::vector mousePosToVector(int x, int y) {
	x -= g_viewportWidth / 2;
	y -= g_viewportHeight / 2;
	return e3ga::_vector((float)x * e3ga::e1 - (float)y * e3ga::e2);
}


void MouseButton(int button, int state, int x, int y) {
	g_rotateModel = false;
	g_translateModel = false;
	if (button == GLUT_LEFT_BUTTON) {
		e3ga::vector mousePos = mousePosToVector(x, y);
		g_prevMousePos = mousePosToVector(x, y);
		g_rotateModel = true;
		if ((_Float(norm_e(mousePos)) / _Float(norm_e(g_viewportWidth * e1 + g_viewportHeight * e2))) < 0.2)
			g_rotateModelOutOfPlane = true;
		else g_rotateModelOutOfPlane = false;
	}
	else if (button == GLUT_RIGHT_BUTTON) {
		g_translateModel = true;
		g_prevMousePos = mousePosToVector(x, y);
	}
}

void MouseMotion(int x, int y) {
	// get mouse position, motion 
	e3ga::vector mousePos = mousePosToVector(x, y);
	e3ga::vector motion = _vector(mousePos - g_prevMousePos);

	if (g_rotateModel) {
		
		// update rotor
		if (g_rotateModelOutOfPlane)
			g_modelRotor = _rotor(e3ga::exp(0.005f * (motion ^ e3ga::e3)) * g_modelRotor);
		else g_modelRotor = _rotor(e3ga::exp(0.00001f * (motion ^ mousePos)) * g_modelRotor);
		
		
	}
	else if (g_translateModel) {
		g_modelDistance -= motion.e2() / 10.0f;
		if (g_modelDistance < 1.0f) g_modelDistance = 1.0f;
		if (g_modelDistance > 100.0f) g_modelDistance = 100.0f;
	}

	// remember mouse pos for next motion:
	g_prevMousePos = mousePos;
	
	// redraw viewport
	glutPostRedisplay();	
}


void menuCallback(int value) {

	// first check for fields:
	int i = 0;
	while (g_fieldFunctions[i].fieldName) {
		if (i == value) {
			printf("New field: %s\n", g_fieldFunctions[i].fieldName);
			g_evalFunc = g_fieldFunctions[i].func;
		}
		i++;
	}

	value -= i;

	// now check for extra options:
	if (value == 0) {
		// show / hide field:
		g_showField = !g_showField;
	}
	
	g_makeNewList = true;
	glutPostRedisplay();
}


int main(int argc, char*argv[]) {
	// profiling for Gaigen 2:
	e3ga::g2Profiling::init();

	// GLUT Window Initialization:
	glutInit (&argc, argv);
	glutInitWindowSize(g_viewportWidth, g_viewportHeight);
	glutInitDisplayMode( GLUT_RGB | GLUT_ALPHA | GLUT_DOUBLE | GLUT_DEPTH);
	glutCreateWindow(WINDOW_TITLE);
	
	// Register callbacks:
	glutDisplayFunc(display);
	glutReshapeFunc(reshape);
	glutMouseFunc(MouseButton);
	glutMotionFunc(MouseMotion);
	
	
	g_GLUTmenu = glutCreateMenu(menuCallback);
	int i = 0;
	for (; g_fieldFunctions[i].fieldName; i++)
		glutAddMenuEntry(g_fieldFunctions[i].fieldName, i);
	glutAddMenuEntry("show/hide vector field", i);
	glutAttachMenu(GLUT_MIDDLE_BUTTON);
	

	glutMainLoop();
	
	return 0;	
}


================================================================================
FILE: src/chap2/ex3/render.cpp
================================================================================
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// Copyright 2007, Daniel Fontijne, University of Amsterdam -- fontijne@science.uva.nl

#ifdef WIN32
#include <windows.h>
#endif

#if defined (__APPLE__) || defined (OSX)
	#include <OpenGL/gl.h>
	#include <OpenGL/glext.h>
	#include <OpenGL/glu.h>
	#include <GLUT/glut.h>
#else
	#include <GL/gl.h>
	#include <GL/glut.h>
#endif

#include <libgasandbox/timing.h>
#include <libgasandbox/gl_util.h>

#include "render.h"
#include "main.h"
#include "hpindex.h"

using namespace e3ga;

GLfloat clearColor[] = {1.0f, 1.0f, 1.0f, 1.0f};
GLfloat lineColor[] = {0.0f, 0.0f, 0.0f, 1.0f};


namespace {
	bool listNamesGenerated = false;;
	GLuint resultListName, cubeListName, fieldListName, 
	  sphereListName, spherePListName, sphereNListName,
	  circListName, circPListName, circNListName;
}
bool g_makeNewList = true;


void drawCube(const vector &p, float size) {
//	printf("%f %f %f, Size: %f\n", pc[0], pc[1], pc[2], size);
	glPushMatrix();
	glTranslatef(p.e1(), p.e2(), p.e3());
	glScalef(size, size, size);
//	printf("Call list: %d\n", cubeListName);
	glCallList(cubeListName);
	glPopMatrix();
}

void drawCube(const vector &p, const vector dir[3]) {
	vector null;
	glBegin(GL_QUADS);

	glNormal3fv(_vector(-dir[2]).getC(vector_e1_e2_e3));
	glVertex3fv(null.getC(vector_e1_e2_e3));
	glVertex3fv(dir[1].getC(vector_e1_e2_e3));
	glVertex3fv(_vector(dir[0] + dir[1]).getC(vector_e1_e2_e3));
	glVertex3fv(dir[0].getC(vector_e1_e2_e3));

	glNormal3fv(dir[0].getC(vector_e1_e2_e3));
	glVertex3fv(dir[0].getC(vector_e1_e2_e3));
	glVertex3fv(_vector(dir[0] + dir[1]).getC(vector_e1_e2_e3));
	glVertex3fv(_vector(dir[0] + dir[1] + dir[2]).getC(vector_e1_e2_e3));
	glVertex3fv(_vector(dir[0] + dir[2]).getC(vector_e1_e2_e3));

	glNormal3fv(dir[2].getC(vector_e1_e2_e3));
	glVertex3fv(_vector(dir[0] + dir[2]).getC(vector_e1_e2_e3));
	glVertex3fv(_vector(dir[0] + dir[1] + dir[2]).getC(vector_e1_e2_e3));
	glVertex3fv(_vector(dir[1] + dir[2]).getC(vector_e1_e2_e3));
	glVertex3fv(dir[2].getC(vector_e1_e2_e3));

	glNormal3fv(_vector(-dir[0]).getC(vector_e1_e2_e3));
	glVertex3fv(dir[2].getC(vector_e1_e2_e3));
	glVertex3fv(_vector(dir[1] + dir[2]).getC(vector_e1_e2_e3));
	glVertex3fv(dir[1].getC(vector_e1_e2_e3));
	glVertex3fv(null.getC(vector_e1_e2_e3));

	glNormal3fv(_vector(-dir[1]).getC(vector_e1_e2_e3));
	glVertex3fv(null.getC(vector_e1_e2_e3));
	glVertex3fv(dir[0].getC(vector_e1_e2_e3));
	glVertex3fv(_vector(dir[0] + dir[2]).getC(vector_e1_e2_e3));
	glVertex3fv(dir[2].getC(vector_e1_e2_e3));

	glNormal3fv(dir[1].getC(vector_e1_e2_e3));
	glVertex3fv(dir[1].getC(vector_e1_e2_e3));
	glVertex3fv(_vector(dir[2] + dir[1]).getC(vector_e1_e2_e3));
	glVertex3fv(_vector(dir[0] + dir[1] + dir[2]).getC(vector_e1_e2_e3));
	glVertex3fv(_vector(dir[0] + dir[1]).getC(vector_e1_e2_e3));

	glEnd();
}

// simple test function which draws the direction of the vector field
void drawVectorField(const vector &base, const vector dir[3],
					 int gs, vector & (*evalFunc)(const vector &p, vector &v), float scale, int unit) {
	int i[3];
	vector p, v;
	float igs = 1.0f / gs;
	glBegin(GL_LINES);
	for (i[0] = 0; i[0] <= gs; i[0]++)
		for (i[1] = 0; i[1] <= gs; i[1]++)
			for (i[2] = 0; i[2] <= gs; i[2]++) {
				// compute position in field
				p = _vector(base + 
					dir[0] * (float)i[0] * igs + 
					dir[1] * (float)i[1] * igs + 
					dir[2] * (float)i[2] * igs);
				// evaluate
				evalFunc(p, v);

				// draw line
				glVertex3fv(p.getC(vector_e1_e2_e3));
				if ( unit ) {
					glVertex3fv(_vector(p + scale * unit_e(v)).getC(vector_e1_e2_e3));
				} else {
				  glVertex3fv(_vector(p + scale * v).getC(vector_e1_e2_e3));
				}
			}
	glEnd();
}


void makeList() {

	// create a cube display list
	vector dir[3], base;
	dir[0] = _vector(e1);
	dir[1] = _vector(e2);
	dir[2] = _vector(e3);
	glNewList(cubeListName, GL_COMPILE);
	drawCube(base, dir);
	glEndList();

	// create vector field display list
	glNewList(fieldListName, GL_COMPILE);
	glColor3f(lineColor[0], lineColor[1], lineColor[2]);

	// set up the cube
	base.set(vector_e1_e2_e3, -0.5f * g_cubeSize+g_cx, -0.5f * g_cubeSize+g_cy, -0.5f * g_cubeSize+g_cz);
	dir[0] = _vector(e1 * g_cubeSize);
	dir[1] = _vector(e2 * g_cubeSize);
	dir[2] = _vector(e3 * g_cubeSize);

	// draw it's vector field
	glDisable(GL_NORMALIZE);
	glDisable(GL_LIGHTING);
	  drawVectorField(base, dir, g_vgs, g_evalFunc, 
			  g_vectorSize*0.05f, g_unitField);
	glEndList();

	glNewList(resultListName, GL_COMPILE);
	// evaluate, draw
	if (g_lighting) {
		glEnable(GL_NORMALIZE);
		glEnable(GL_LIGHTING);
		glEnable(GL_LIGHT0);
	}
	glEnable(GL_CULL_FACE);
	glCullFace(GL_BACK);
	double t = u_timeGet();
	extern int g_refines;
	g_boxes=0; g_refines=0;
	printf("Finding singularities (can take a while). . .\n");
	findSingularities(base, dir, g_gs, g_evalFunc, 0, g_maxDepth);
	g_lastTiming = u_timeGet() - t;
	printf("%f secs\n", g_lastTiming);
//	timerCallback(NULL); // WHAT DID THIS DO???
	glEndList();
	if ( g_Dcube > 0 ) {
	  glNewList(sphereListName, GL_COMPILE);
	  glDisable(GL_NORMALIZE);
	  glDisable(GL_LIGHTING);
	  drawSphere(g_gs, 0);
	  glEndList();

	  glNewList(spherePListName, GL_COMPILE);
	  if (g_lighting) {
		glEnable(GL_NORMALIZE);
		glEnable(GL_LIGHTING);
		glEnable(GL_LIGHT0);
	  }
	  drawSphere(g_gs,1);
	  glEndList();

	  glNewList(sphereNListName, GL_COMPILE);
	  if (g_lighting) {
		glEnable(GL_NORMALIZE);
		glEnable(GL_LIGHTING);
		glEnable(GL_LIGHT0);
	  }
	  drawSphere(g_gs,2);
	  glEndList();



	  glNewList(circListName, GL_COMPILE);
	  glDisable(GL_NORMALIZE);
	  glDisable(GL_LIGHTING);
	  drawCirc(g_gs, 0);
	  glEndList();

	  glNewList(circPListName, GL_COMPILE);
	  if (g_lighting) {
		glEnable(GL_NORMALIZE);
		glEnable(GL_LIGHTING);
		glEnable(GL_LIGHT0);
	  }
	  drawCirc(g_gs,1);
	  glEndList();

	  glNewList(circNListName, GL_COMPILE);
	  if (g_lighting) {
		glEnable(GL_NORMALIZE);
		glEnable(GL_LIGHTING);
		glEnable(GL_LIGHT0);
	  }
	  drawCirc(g_gs,2);
	  glEndList();
	}
}

void drawAll() {
	if (!listNamesGenerated) {
		resultListName = glGenLists(9);
		cubeListName = resultListName + 1;
		fieldListName = resultListName + 2;
		sphereListName = resultListName +3;
		spherePListName = resultListName +4;
		sphereNListName = resultListName +5;
		circListName = resultListName +6;
		circPListName = resultListName +7;
		circNListName = resultListName +8;
		listNamesGenerated = true;
		g_makeNewList = true;
	}
	if (g_makeNewList) {
		makeList();
		g_makeNewList = false;
	}

	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();


	if (g_showField) {
	  glCallList(fieldListName);
	}

	if (g_showResult) {
	  glCallList(resultListName);
	}

	if (g_showSphere && g_Dcube>0) {
	  glCallList(sphereListName);
	}
	if (g_showPSphere && g_Dcube>0) {
	  glCallList(spherePListName);
	}
	if (g_showNSphere && g_Dcube>0) {
	  glCallList(sphereNListName);
	}

	if ( g_showCirc && g_Dcube > 0 ) {
	  glCallList(circListName);
	  glCallList(circPListName);
	  glCallList(circNListName);
	}
	glPopMatrix();
}


================================================================================
FILE: src/chap2/ex3/fields.h
================================================================================
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// Copyright 2007, Daniel Fontijne, University of Amsterdam -- fontijne@science.uva.nl

#ifndef _MRS_FIELDS_H_
#define _MRS_FIELDS_H_

#include <libgasandbox/e3ga.h>
using namespace e3ga;

extern double g_fieldsCurrentTime; // should be set to current time before calling the eval functions


extern float g_dx;
extern float g_dy;
extern float g_dz;
extern float g_omega;
extern float g_gamma;
extern float g_Rcore;
  
e3ga::vector &vortex(const e3ga::vector& p, e3ga::vector& v);
e3ga::vector &vortexS(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &vortexA(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &vortexO(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &point3(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &line3(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &testFunc3(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &testFunc4(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &testFunc5(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &testFunc6(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &testFunc7(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &testFunc8(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &testFunc9(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &testFunc10(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &testFunc11(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &testFunc12(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &testFunc13(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &testFunc14(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &testFunc15(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &testFunc16(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &testFunc16a(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &testFunc17(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &testFunc18(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &helix3(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &const3(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &circ3(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &sphere3(const e3ga::vector &p, e3ga::vector &v);
e3ga::vector &eight2(const e3ga::vector &p, e3ga::vector &v);


#endif /* _MRS_FIELDS_H_ */


================================================================================
FILE: src/chap2/ex3/hpindex.h
================================================================================
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// Copyright 2007, Daniel Fontijne, University of Amsterdam -- fontijne@science.uva.nl

#ifndef _HP_INDEX_H_
#define _HP_INDEX_H_

#include <libgasandbox/e3ga.h>

int sumFace(const e3ga::vector &p, const e3ga::vector &v1, const e3ga::vector &v2, 
	    const int gsi, e3ga::vector &sum3d, int &lineSing, int &surfSing,
	    e3ga::vector & (*evalFunc)(const e3ga::vector &p, e3ga::vector &v), int depth, 
	    int maxDepth, int face);

int sumCube(const e3ga::vector &p, const e3ga::vector dir[3],
		 const int gsi, int &pointSing, int &lineSing, int &surfSing,
		 e3ga::vector & (*evalFunc)(const e3ga::vector &p, e3ga::vector &v), int depth, int maxDepth);

int	findSingularities(const e3ga::vector &p, const e3ga::vector dir[3],
		 const int gsi, e3ga::vector & (*evalFunc)(const e3ga::vector &p, e3ga::vector &v), int depth, int maxDepth);

	// simple function to draw sphere of e3ga::vectors around one cube
	void drawSphere(int gs, int type);
	void drawCirc(int gs, int type);

#endif /* _HP_INDEX_H_ */


================================================================================
FILE: src/chap2/ex3/main.h
================================================================================
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// Copyright 2007, Daniel Fontijne, University of Amsterdam -- fontijne@science.uva.nl

#ifndef _MAIN_H_
#define _MAIN_H_

#include <libgasandbox/e3ga.h>


extern e3ga::vector & (*g_evalFunc)(const e3ga::vector &p, e3ga::vector &v);
extern int g_gs, g_vgs, g_maxDepth,g_adap;
extern double g_lastTiming;
extern int g_boxes;
extern float g_cubeSize;
extern int g_showField, g_showOctree, g_showResult, g_unitField, g_bottom;
extern int g_lineSing, g_surfSing;
extern int g_falseLineSing, g_falseSurfSing;
extern float g_vectorSize;
extern float g_sratio, g_lratio;
extern float g_psing, g_lsing;
extern float g_cx, g_cy, g_cz;
extern float g_refine;
extern float l_refine;
extern int g_lighting;

extern int g_Dcube;
extern int g_showSphere;
extern int g_showPSphere;
extern int g_showNSphere;
extern int g_showCirc;

extern int g_USphere;
extern int g_ISphere;
extern float g_hpvalue;

extern e3ga::rotor g_modelRotor;
extern float g_modelDistance;


#endif /* _MAIN_H_ */


================================================================================
FILE: src/chap2/ex3/render.h
================================================================================
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// Copyright 2007, Daniel Fontijne, University of Amsterdam -- fontijne@science.uva.nl

#ifndef _CHAP2_EX3_RENDER_H_
#define _CHAP2_EX3_RENDER_H_

#include <libgasandbox/e3ga.h>

extern bool g_makeNewList;
extern GLfloat lineColor[];

void drawCube(const e3ga::vector &p, float size);
void drawAll();


#endif /* _CHAP2_EX3_RENDER_H_ */


================================================================================
FILE: src/chap2/solutions/ex2/chap2ex2s.cpp
================================================================================
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

// Copyright 2007, Daniel Fontijne, University of Amsterdam -- fontijne@science.uva.nl

#ifdef WIN32
#include <windows.h>
#endif

#include <GL/gl.h>
#include <GL/glut.h>
#include <stdio.h>
#include <stdlib.h>

#include <vector>
#include <string>

#include <libgasandbox/common.h>
#include <libgasandbox/e2ga.h>
#include <libgasandbox/e3ga_util.h>
#include <libgasandbox/gl_util.h>
#include <libgasandbox/glut_util.h>

using namespace e2ga;

const char *WINDOW_TITLE = "Geometric Algebra, Chapter 2, Example 2: Hidden Surface Removal (SOLUTION)";

// GLUT state information
int g_viewportWidth = 800;
int g_viewportHeight = 600;
int g_GLUTmenu;
// mouse position on last call to MouseButton() / MouseMotion()
e3ga::vector g_prevMousePos;
// when true, MouseMotion() will rotate the model
bool g_rotateModel = false;
bool g_rotateModelOutOfPlane = false;

// model info:
bool g_initModelRequired = true;
const char *g_modelName = "sphere";

// vertex positions: 2d vectors
std::vector<e2ga::vector> g_vertices2D;
// indices into the g_vertices2D vector:
std::vector<std::vector<int> > g_polygons2D;

e3ga::rotor g_modelRotor(e3ga::_rotor(1.0f));
std::string g_prevStatisticsModelName = "";

// model names:
const char *g_modelNames[] = {
"teapot",
"cube",
"sphere",
"cone",
"torus",
"dodecahedron",
"octahedron",
"tetrahedron",
"icosahedron",
NULL
};



void getGLUTmodel2D(const std::string &modelName);



// *!*HTML_TAG*!* display
// SPOILER WARNING: below is the solution to Chapter 2, exercise 2.
void display() {
	doIntelWarning(); // warn for possible problems with pciking on Intel graphics chipsets

	glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	// get model, if required:
	if (g_initModelRequired) {
		g_initModelRequired = false;
		getGLUTmodel2D(g_modelName);
	}

	glEnable(GL_DEPTH_TEST);

	// DONT cull faces (we will do this ourselves!)
	glDisable(GL_CULL_FACE);
	// fill all polygons (otherwise they get turned into LINES)
	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

	glColor3f(0.0f, 0.0f, 0.0f);

	bivector B;

	// render model
	for (unsigned int i = 0; i < g_polygons2D.size(); i++) {
		// get 2D vertices of the polygon:
		const e2ga::vector &v1 = g_vertices2D[g_polygons2D[i][0]];
		const e2ga::vector &v2 = g_vertices2D[g_polygons2D[i][1]];
		const e2ga::vector &v3 = g_vertices2D[g_polygons2D[i][2]];

		// Exercise:
		// Insert code to remove back-facing polygons here.
		// You can extract the e1^e2 coordinate of a bivector 'B' using:
		// float c = B.e1e2();
		B = (v2 - v1) ^ (v3 - v1);
		if (B.e1e2() <= 0.0) continue;

		// draw polygon
		glBegin(GL_POLYGON);
		for (unsigned int j = 0; j < g_polygons2D[i].size(); j++)
			glVertex2f(
				g_vertices2D[g_polygons2D[i][j]].e1(),
				g_vertices2D[g_polygons2D[i][j]].e2());
		glEnd();
	}

	glutSwapBuffers();
}

void reshape(GLint width, GLint height) {
	g_viewportWidth = width;
	g_viewportHeight = height;

	glViewport(0, 0, g_viewportWidth, g_viewportHeight);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(0, g_viewportWidth, 0, g_viewportHeight, -100.0, 100.0);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	// refresh model on next redraw
	g_initModelRequired = true;

	// redraw viewport
	glutPostRedisplay();
}

e3ga::vector mousePosToVector(int x, int y) {
	x -= g_viewportWidth / 2;
	y -= g_viewportHeight / 2;
	return e3ga::_vector((float)x * e3ga::e1 - (float)y * e3ga::e2);
}


void MouseButton(int button, int state, int x, int y) {
	if (button == GLUT_LEFT_BUTTON) {
		e3ga::vector mousePos = mousePosToVector(x, y);
		g_prevMousePos = mousePosToVector(x, y);
		g_rotateModel = true;
		if ((_Float(norm_e(mousePos)) / _Float(norm_e(g_viewportWidth * e1 + g_viewportHeight * e2))) < 0.2)
			g_rotateModelOutOfPlane = true;
		else g_rotateModelOutOfPlane = false;
	}
	else g_rotateModel = false;
}

void MouseMotion(int x, int y) {
	if (g_rotateModel) {
		// get mouse position, motion
		e3ga::vector mousePos = mousePosToVector(x, y);
		e3ga::vector motion = _vector(mousePos - g_prevMousePos);

		// update rotor
		if (g_rotateModelOutOfPlane)
			g_modelRotor = _rotor(e3ga::exp(0.005f * (motion ^ e3ga::e3)) * g_modelRotor);
		else g_modelRotor = _rotor(e3ga::exp(0.00001f * (motion ^ mousePos)) * g_modelRotor);


		// remember mouse pos for next motion:
		g_prevMousePos = mousePos;

		// refresh model on next redraw
		g_initModelRequired = true;

		// redraw viewport
		glutPostRedisplay();
	}
}

void Keyboard(unsigned char key, int x, int y) {

}


void menuCallback(int value) {
	g_modelName = g_modelNames[value];
	g_initModelRequired = true;
	glutPostRedisplay();
}


int main(int argc, char*argv[]) {
	// profiling for Gaigen 2:
	e2ga::g2Profiling::init();
	e3ga::g2Profiling::init();

	// GLUT Window Initialization:
	glutInit (&argc, argv);
	glutInitWindowSize(g_viewportWidth, g_viewportHeight);
	glutInitDisplayMode( GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);
	glutCreateWindow(WINDOW_TITLE);

	// Register callbacks:
	glutDisplayFunc(display);
	glutReshapeFunc(reshape);
	glutKeyboardFunc(Keyboard);
	glutMouseFunc(MouseButton);
	glutMotionFunc(MouseMotion);


	g_GLUTmenu = glutCreateMenu(menuCallback);
	for (int i = 0; g_modelNames[i]; i++)
		glutAddMenuEntry(g_modelNames[i], i);
	glutAttachMenu(GLUT_MIDDLE_BUTTON);
	glutAttachMenu(GLUT_RIGHT_BUTTON);


	glutMainLoop();

	return 0;
}

void getGLUTmodel2D(const std::string &modelName) {
	// DONT cull faces (we will do this ourselves!)
	glDisable(GL_CULL_FACE);
	// fill all polygons (otherwise they get turned into LINES
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

	// setup projection & transform for the model:
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	const float screenWidth = 1600.0f;
	glFrustum(
		-(float)g_viewportWidth / screenWidth, (float)g_viewportWidth / screenWidth,
		-(float)g_viewportHeight / screenWidth, (float)g_viewportHeight / screenWidth,
		1.0, 100.0);

	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();
	glTranslatef(0.0, 0.0, -10.0f);

	rotorGLMult(g_modelRotor);


	glColor3f(0.0f, 0.0f, 0.0f);

	// buffer for OpenGL feedback.
	// Format will be:
	// GL_POLYGON_TOKEN
	// n (= 3)
	// vertex 0 x, vertex 0 y
	// vertex 1 x, vertex 1 y
	// vertex 2 x, vertex 2 y
	// GL_POLYGON_TOKEN etc etc
	std::vector<GLfloat> buffer(300000); // more than enough for the GLUT primitives

	// switch into feedback mode:
	glFeedbackBuffer((GLsizei)buffer.size(), GL_2D, &(buffer[0]));
	glRenderMode(GL_FEEDBACK);

	// render model
	if (modelName == "teapot")
		glutSolidTeapot(1.0);
	else if (modelName == "cube")
		glutSolidCube(1.0);
	else if (modelName == "sphere")
		glutSolidSphere(1.0, 16, 8);
	else if (modelName == "cone")
		glutSolidCone(1.0, 2.0, 16, 8);
	else if (modelName == "torus")
		glutSolidTorus(0.5, 1.0, 8, 16);
	else if (modelName == "dodecahedron")
		glutSolidDodecahedron();
	else if (modelName == "octahedron")
		glutSolidOctahedron();
	else if (modelName == "tetrahedron")
		glutSolidTetrahedron();
	else if (modelName == "icosahedron")
		glutSolidIcosahedron();

	int nbFeedback = glRenderMode(GL_RENDER);

	// parse the buffer:
	g_polygons2D.clear();
	g_vertices2D.clear();

	int idx = 0;
	while (idx < nbFeedback) {
		// check for polygon:
		if (buffer[idx] != GL_POLYGON_TOKEN) {
			fprintf(stderr, "Error parsing the feedback buffer!");
			break;
		}
		idx++;

		// number of vertices (3)
		int n = (int)buffer[idx];
		idx++;
		std::vector<int> vtxIdx(n);

		// get vertices:
		// Maybe todo later: don't duplicate identical vertices  . . .
		for (int i = 0; i < n; i++) {
			vtxIdx[i] = (int)g_vertices2D.size();
			g_vertices2D.push_back(_vector(buffer[idx] * e1 + buffer[idx+1] * e2));
			idx += 2;
		}

		g_polygons2D.push_back(vtxIdx);
	}

	if (g_prevStatisticsModelName != modelName) {
		printf("Model: %s, #polygons: %d, #vertices: %d\n", modelName.c_str(), g_polygons2D.size(), g_vertices2D.size());
		g_prevStatisticsModelName = modelName;
	}

	// restore transform & projection:
	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
	glMatrixMode(GL_MODELVIEW);

}


